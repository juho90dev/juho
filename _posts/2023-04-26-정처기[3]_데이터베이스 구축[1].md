---
layout: post
title: 정처기[3]_데이터베이스 구축[1]
---

## 정처기_데이터베이스 구축 요약[1]

### 논리 데이터 베이스 설계

#### 데이터베이스 설계

1. __데이터베이스 설계 시 고려사항__
    - 무결성
    - 일관성
    - 회복
    - 보안
    - 효율성
    - 데이터베이스 확장

2. __데이터베이스 설계 순서__
    - 요구 조건 문석 : 요구 조건 명세서 작성
    - 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
    - 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
    - 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
    - 구현 : 목표 DBMS의 DDL로 데이터베이스 생성, 트랜잭션 작성

3. __개념적 설계(정보 모델링, 개념화)__
    - 현실 세계에 대한 인식을 추상적 개념으로 포현하는 과정
    - 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행
    - 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
    - DBMS에 독립적인 개념 스키마를 설계
    - E-R(Entity-Relation) 모델

4. __논리적 설계(데이터 모델링)__
    - 자료를 물리적 저장장치에 저장 할수 있도록 특정 DBMS가 지원하는 자료구조로 변환시키는 과정
    - 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계
    - 트랜잭션의 인터페이스를 설계
    - 관계 모델, 계층 모델, 네트워크 모델

5. __물리적 설계(데이터 구조화)__
    - 논리적 구조로 표현된 데이터를 물리적 주고의 데이터로 변환하는 과정
    - 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정
    - 고려 사항
        - 트랜잭션 처리량
        - 응답 시간
        - 디스크 용량
        - 저장 공간의 효율화 


#### 데이터 모델

1. __데이터 모델__
    - 현실 세계의 정보를 컴퓨터에 표현하기 위해서 단순화, 추사화하여 체계적으로 표현한 개념적 모형
    - 구성 요소
        - 개체(Entity) : 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
        - 속성(Attribute) : 데이터의 가장 작은 논리적 단위로서 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
        - 관계(Realationship) : 개체 간의 관계 또는 속성간의 논리적인 연결을 의미

2. __데이터 모델에 표시할 요소__
    - 구조(Structure) : 논리적인 개체 타입들간의 관계, 데이터 구조 및 정적 성질을 표현함
    - 연산(Operation) : 실제 데이터를 처리하는 작업에 대한 명세, 데이터베이스를 조작하는 기본 도구
    - 제약 조건(Constraint) : 실제 데이터의 논리적인 제약 조건


#### 객체

1. __개체(Entity)__
    - 실세계에 독립적으로 존재하는 유형,무형의 정보로 서로 연관된 몇 개의 속성으로 구성
    - 데이터베이스에 표현하려는 것으로 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
    - 독립적으로 존재하거나 그 자체로서도 구별 가능
    - 유일한 식별자(Unique Identifier)에 의해 식별 가능
    - 다른 개체와 하나 이상의 관계(Relationship)가 있음

2. __개체 선정 방법__
    - 실제 업무를 담당하고 있는 담당자와 인터뷰를 함
    - 실제 업무에 사용되고 있는 장부와 전표를 이용
    - 자료 흐름도(DFD, Data Flow Diagram)를 통해 업무 분석을 수행했을 경우 자료 흐름도의 자료저장소를 이용함
    - BPR(Business Process Reengineering, 업무 프로세스 재설계)에 의해 업무를 재정의한 경우 관련 개체를 찾음

3. __개체명 지정 방법__
    - 일반적으로 해당 업무에서 사용하는 용어로 지정
    - 약어 사용은 되도록 제한
    - 가능하면 단수 명사 사용
    - 모든 개체명은 유일해야 함
    - 가능하면 개체가 생성되는 의미에 따라 이름 부여


#### 속성

1. __속성의 정의 및 특징__
    - 데이터베이스를 구성하는 가장 작은 논리적 단위
    - 파일 구조상의 데이터 항목 또는 데이터 필드
    - 개체를 구성하는 항목 및 개체의 특성을 기술
    - 속성의 수를 디그리(Degree) 또는 차수라고 함

2. __속성에 따른 분류__
    - 기본 속성(Basic Attribute) : 업무 분석을 통해 정의한 속성
    - 설계 속성(Designed Attribute) : 원래 업무상 존재하지 않고 설계 과정에서 도출해낸 속성
    - 파생 속성(Derived Attribute) : 다른 속성으로부터 영향을 받아 발생하는 속성

3. __개체 구성 방식에 따른 분류__
    - 기본 키 속성(Primary key Attribute) : 개체를 식별할 수 있는 속성
    - 외래 키 속성(Foreign Key Attribute) : 다른 개체와의 관계에서 포함된 속성
    - 일반 속성 : 개체에 포함되어 있고 기본 키, 외래 킹에 포함되지 않은 속성

4. __속성명 지정 원칙__
    - 해당 업무에서 사용하는 용어 지정
    - 서술형으로 지정하지 않음
    - 가급적 약어의 사용은 제한
    - 개체명은 속성명으로 사용할 수 없음
    - 개체에서 유일하게 식별 가능하도록 지정

#### 관계(Realationship)

1. __관계의 형태__
    - 일대일(1:1) : 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계
    - 일대다(1:N) : 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계
    - 다대다(N:N) : 개체 집합 A와 B 모두 서로의 원소 여러개와 대응 하는 관계


2. __관계의 종류__
    - 종속(Dependant) 관계
    - 중복(Redundant) 관계
    - 재귀(Recursive) 관계
    - 배타(Exclusive) 관계



#### 식별자(Identifier)

1. __식별자__
    - 하나의 객체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자
    - 모든 개체는 한 개 이상의 식별자를 반드시 가져야 함
    - 분류
        - 대표성 여부 : 주 식별자, 보조 식별자
        - 스스로 생성 여부 : 내부식별자, 외부 식별자
        - 단일 속성 여부 : 단일 식별자, 복합 식별자
        - 대체 여부 : 원조 식별자, 대리 식별자
2. __주식별자 / 보조 식별자__
    - 주 식별자(Primary Identifier)
        - 개체를 대표하는 유일한 식별자
        - 하나의 개체에 한 개만 존재
    - 보조 식별자(Alternate Identifier)
        - 주 식별자를 대신하여 개체를 식별할 수 있는 속성 
        - 하나의 개체에 한 개 이상 존재
    - 개체를 유일하게 식별할 수 있는 속성이 두 개 이상인 경우 가장 적합한 속성을 주 식별자로 지정
    - 물리적 테이블에서 주 식별자는 기본키로, 보조 식별자는 유니크 인덱스로 지정되어 사용

    - 주 식별자의 4가지 특징
        - 유일성 : 주 식별자에 의해 개체 니에 모든 인스턴스들이 유일하게 구분되어야 한다.
        - 최소성 : 주 식별자를 구성하는 속성의 수는 유일성을 만족하는 최소 수가 되어야 한다.
        - 불변성 : 주 식별자가 한 번 특정 개체에 지정되면 그 식별자는 변하지 않아야 한다.
        - 존재성 : 주 식별자가 지정되면 식별자 속성에 반드시 데이터 값이 존재해야 한다.

3. __내부 식별자 / 복합 식별자__
    - 내부 식별자(Internal Identifier)
        - 개체 내에서 스스로 만들어지는 식별자
    - 외부 식별자(Foreign Identifier)
        - 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용하는 식별자
        - 자신의 개체에서 다른 개체를 찾아가는 연결자 역할

4. __단일 식별자 / 복합 식별자__
    - 단일 식별자(Single Identifier)
        - 주 식별자가 한 가지 속성으로만 구성된 식별자
    - 복합 식별자(Commposit Identifier)
        - 주 식별자가 두 개 이상의 속성으로 구성된 식별자

5. __원조 식별자 / 대리 식별자__
    - 원조 식별자(Original Identifier)
        - 업무에 의해 만들어지는 가공되지 않은 원래의 식별자(본질 식별자라고도 한다)
    - 대리 식별자(Surrogate Identifier)
        - 주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자(인조 식별자라고도 한다)
        - 조건
            - 최대한 범용적인 값을 사용
            - 유일한 값을 만들기 위한 대리 식별자를 사용
            - 하나의 대리 식별자 속성으로 대체할 수 없는 경우를 주의한다.
            - 편의성과 단순성, 의미의 체계화를 위한 대리 식별자 사용할 수 있다
            - 시스템적인 필요성에 의해 내부적으로만 사용하는 대리 식별자를 사용할 수 있다

6. __후보식별자__
    - 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성집합
    - 하나의 개체에는 한 개 이상의 후보 식별자가 있다.
    - 조건
        - 각 인스턴스를 유일하게 식별할 수 있어야 한다.
        - 직접 식별할 수 있어야 한다.
        - 널값이 될 수 없다. 




#### E-R(개체-관계) 모델

1. __E-R(개체-관계) 모델 개요__
    - 개념적 데이터 모델의 가장 대표적인 것으로, 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립
    - 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현
    - 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사
    - 다이어그램으로 표현하며 관계 유형을 제한없이 나타낼 수 있다.

2. __E-R 다이어그램(Entity-Relationship Diagram)
    - 사각형 : 개체 타입
    - 마름모  : 관계타입
    - 타원 : 속성
    - 이중 타원 : 다중값 속성
    - 밑줄 타원 : 기본키 속성
    - 복수 타우너 : 복합 속성
    - 관계 : 1:1, 1:N, N:M 등의 개체 간 관계에 대한 대응수를 선 위에 기술
    - 선, 링크 : 개체 타입과 속성을 연결


#### 관계형 데이터 모델

1. __관계형 데이터 모델의 개요__
    - 2차원적인 표(Table)를 이용해서 데이터 상호관걔를 정의하는 DB구조
    - 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계(Relationship)를 설정하거나 테이블 간의 관계를 설정하여 이용
    - 기본키(Primary Key)와 이를 참조하는 외래키(Foreign Key)로 데이터 간의 관계를 표현
    - 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
    - 대표적인 언어는 SQL

2. __관계형 데이터베이스의 Relation구조__
    - 릴레이션은 데이터들을 표의 형태로 표현한 것으로 구졸르 나타내는 릴레이션 스키마와 살제값들인 릴레이션 인스턴스로 구성된다.
    - 튜플(Tuple)
        - 릴레이션을 구성하는 각각의 행
        - 속성의 모임으로 구성
        - 파일 구조에서 레코드와 같은 의미
        - 튜플(Tuple)의 수는 카디널리티(Cardinality) 또는 기수, 대응수라고 한다. 
    - 속성(Attribute)
        - 데이터베이스를 구성하는 가장 작은 논리적 단위
        - 개체의 특성을 기술
        - 속성의 수를 디그리 또는 차수라고 한다. 
    - 도메인(Domain)
        - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값들의 집합
        - 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데 이용 

3. __릴레이션의 특징__
    - 릴레이션에 포함된 튜플들은 모두 상이하다.
    - 한 릴레이션에 포함된 튜플 사이에는 순서가 없다
    - 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
    - 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.
    - 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다.
    - 튜플을 유일하게ㅜ 식별하기 위해 속성들의 부부집합을 키로 설정한다. 
    - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다.



#### 관계형데이터베이스틔 제약 조건 - 키(Key)
- 제약 조건 : 데이터베이스에 저장되는 데이터의 정확성을 보장하기 위하여 키를 이용하여 입력되는 데이터에 제한을 주는 것
1. __키(Key)의 개념 및 종류__
    - 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 튜플들을 서로 구분할 수 있는 기누이 되는 애트리뷰트를 말한다.

2. __후보키(Candidate Key)__
    - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합 = 기본키로 사용할 수 있는 속성들
    - 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재
    - 모든 튜플에 대해서 유일성과 최소성을 만족시켜야함
        - 유일성(Unique) : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
        - 최소성 (Minimality) : 모든 레코드들을 유일하게 식별하는데 꼭 필요한 속성으로만 구성되어야 한다.

3. __기본키(Primary Key)__
    - 후보키 중에서 특별히 선정된 주키(Main key)로 중복된 값을 가질 수 없다.
    - 한 릴레이션에서 특정 튜플을 유일하게 식별할 수 있는 속성
    - NULL 값을 가질수 ㅇ벗다.

4. __대체키(Alternate Key)__
    - 후보키가 둘 이상일때 기본키를 제외한 나머지 후보키
    - 보조키라고도 함.

5. __슈퍼키(Super Key)__
    - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
    - 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않음
    - 모든 튜플에 대해 유일성은 만족시키지만, 최소성은 만족시키지 못한다.

6. __외래키(Foreign Key)__
    - 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합
    - 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조관계를 표현하는데 중요한 도구
    - 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.


#### 관계형데이터베이스틔 제약 조건 - 무결성

1. __무결성(Integrity)의 개념 및 종류__
    - 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미
    - 무결성 제약 조건은 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건
    - 무결성의 종류
        - 개체 무결성(Entity Integrity, 실체 무결성)
            - 기본 테이블의 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가질 수 없다는 규정
        - 도메인 무결성(Domain Integrity, 영역 무결성)
            - 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정 
        - 참조 무결성(Referential Integrity)
            - 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정 
        - 사용자 정의 무결성(User-Defined Integrity)
            - 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정

2. __데이터 무결성__
    - 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 한다.
    - 데이터베이스 구축 과정에서 정의
    - 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용하여 강화 할 수 있다.
    - 애플리케이션
        - 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 데이터를 조작하는 프로그램 내에 추가 
        - 장점 : 사용자 정의같은 무결성 조건의 구현이 가능
        - 단점 : 소스 코드에 분산되어 있어 관리가 힘들고, 개별적인 시행으로 인해 적정성 검토가 어렵다.
    - 데이터베이스 트리거
        - 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가
        - 장점 : 통합 관리가 가능, 복잡한 요구 조건의 구현이 가능하다.
        - 단점 : 운영 중 변경이 어렵고, 사용상 주의가 필요하다.
    - 제약조건
        - 데이터베이스에 제약 조건을 설정하여 무결성을 유지
        - 장점 : 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지 등
        - 단점 : 복잡한 제약 조건의 구현과 예외적인 처리가 불가능  
    


#### 관계대수 및 관계해석

1. __관계대수의 개요__
    - 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적 언어
    - 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하는 언어
    - 피연산자가 릴레이션이며 결과 또한 릴레이션
    - 순수 관계 연산자 : Select, Project, Join, Division
    - 일반 집합 연산자 : UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)


2. __순수 관계 연산자__
    - Select
        - 릴레이션에 존재하는 튜플중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산
        - 수평연산이라고도 하며 연산자의 기호응 시그마(σ)를 사용한다. 
        - 표기 형식
            - σ<조건>(R)
            - R은 릴레이션 이름 
    - Project
        - 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
        - 연산 결과에 중복이 발생하면 중복 제거
        - 수직연산이라고도 하며 파이(π)를 사용
        - 표기 형식
            - π(속성리스트)(R)

    - Join
        - 공통 속성을 중심으로 두 개의 리레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
        - Join의 결과로 만들어진 릴레이션의 차수는 조인된 두 릴레이션의 차수를 합한 것과 같다.
        - 표기 형식
            - R▷◁키속성r=키속성s S
            - 키 속성 r은 릴레이션 R의 속성이고, 키 속성 S는 릴레이션 S의 속성이다.

    - Division
        - X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
        - 표기 형식
            - R[속성r ÷ 속성s]S 


3. __일반 집합 연산자__
    - 수학적 지론에서 사용하는 연산자
    - 합집합(UNION) ∪
        - 기능 및 수학적 표현
            - 두 릴레이션에 존재하는 튜플의 합집합, 결과로 생성된 릴레이션에서 중복된 튜플을 제거한다.
        - 카디널리티
            - 합집합의 카디널리티는 두 릴레이션의 카디널리티의 합보다 크지 않다.    
    - 교집합(NTERSECTION) ∩ 
        - 기능 및 수학적 표현
            - 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산
        - 카디널리티
            - 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다.   
    - 차집합(DIFFERNECE) -
        - 기능 및 수학적 표현
            - 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
        - 카디널리티
            - 차집합의 카디널리티는 릴레이션 R의 카디널리티보다 크지 않다.   
    - 교차곱(CARTESIAN PRODUCT) ×
        - 기능 및 수학적 표현
            - 두 릴레이션에 존재하는 튜플의 순서쌍을 구하는 연산
        - 카디널리티
            - 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한것과 같다. 

3. __관계 해석Relational Calculus)__
    - 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안
    - 관계 데이터의 연산을 표현하는 방법, 원하는 정보를 정의할 때는 계산 수식을 사용
    - 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성
    - 튜플 관계해석과 도메인 관계해석이 있다.
    - 기본적으로 관계해석과 관계대수는 관계 데이터베이스를 처리하는 기능과 능력면에서 동등하며, 관계 대수로 표현한 식은 관계해석으로 표현 가능
    - 질의어로 표현


#### 정규화

1. __정규화의 개요__
    - 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 과정
    - 하나의 종속석이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
    - 정규형에는 제1정규형 ~ 제 5정규형이 있으며, 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다.
    - 데이터베이스의 논리적 설계 단계에서 수행
    - 논리적 처리 및 품질에 큰 영향을 미친다.
    - 정규화된 데이터 모델은 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장

2. __정규화의 목적__
    - 데이터 구조의 안정성 및 무결성을 유지
    - 어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능
    - 효과적인 검색 알고리즘 생성 가능
    - 데이터 중복을 배제하여 이상(Anomaly)의 발생 방지 및 자료 저장 공간의 최소화가 가능
    - 데이터 삽입 시 릴레이션을 재구성할 필요성을 줄인다.
    - 데이터 모형의 단순화가 가능
    - 속성의 배열 상태 검증이 가능
    - 개체와 속성의 누락 여부 확인이 가능
    - 자료 검색과 추출의 효율성을 추구

3. __이상(Anomaly)의 개념 및 종류__
    - 데이터베이스 내에 데이터들이 불필요하게 중복되어 릴레이션 조작 시 예기치 못한 곤란한 현상
    - 삽입 이상(Inertion Anomaly)
        - 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상
    - 삭제 이상(Deletion Anomaly)
        - 한 튜플을 삭제할 때 의도화는 상관없는 값들도 함께 삭제되는 연쇄가 일어나는 현상 
    - 갱신 이상(Update Anomaly)
        - 튜플에 있는 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상

4. __정규화의 원칙__
    - 정보의 무손실 표현
    - 분리의 원칙
    - 데이터의 중복성 감소

5. __정규화 과정__
    - 1NF(제1정규형) : 모든 도메인이 원자값
    - 2NF(제2정규형)
        - 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형
        - 릴레이션 R 1NF
        - 부분적 함수 종속 제거
    - 3NF(제3정규형)
        - 기본키가 아닌 모든 속성이 기본키에 대하여 이행적 종속을 만족하지 안하는 정규형
        - 릴레이션 R이 2NF
        - 이행적 함수 종속 제거
    - BCNF(Boyce-Codd 정규형)
        - 릴레이션 R에서 결정자가 모두 후보키인 정규형
        - 3NF에서 후보키기ㅏ 여러 개 존재하고 서로 중첩되는 경우에 적용하는, 강한 제3정규형이라고도 한다.
        - 제약 조건
            - 키가 아닌 모든 속성은 각 키에 대하여 완전 종속해야 한다.
            - 키가 아닌 모든 속성은 그 자신이 부분적으로 들어가 있지 않은 모든 키에 디해야 완전 종속해야 한다.    
            - 어떤 속성도 키가 아닌 속성에 대해서는 완전 종속할 수 없다.
    - 4NF(제4정규형)
        - 리리레이션 R에 다치 종속 A ->>B가 성립하는 경우 R의 모든 속성이 A의 함수적 종속 관계를 만족하는 정규형
        - 다치 종속 제거
    - 5NF(제5정규형, PJ/NF)
        - 5NF는 릴레이션 R의 모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형
        - 조인 종속성 이용
    


#### 반정규화

1. __반정규화의 개념__
    - 정규화된 데이터 모델을 통합, 중복, 분리하는 과정으로, 의도적으로 정규화 원칙을 위배하는 행위
    - 시스템의 성능이 향상되고 관리 효율성을 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다.
    - 과도한 반정규화는 성능 저하 가능
    - 방법에는 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가 등이 있다.

2. __테이블 통합__
    - 두 개의 테이블이 조인(Join)되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능향상에 도움이 될 경우 수행
    - 종류에는 1:1 관계 테이블 통합, 1:N 관계 테이블 통합, 슈퍼타입/서브타입 테이블 통합이 있다.
    - 고려 사항
        - 검색은 간편하지만 레코드 증가로 인해 처리량이 증가
        - 테이블 통합으로 인해 입력, 수정, 삭제 규칙이 복잡해질 수 있다.
        - Not Null, Default, Check 등의 제약 조건(Constraint)을 설계하기 어렵다.

3. __테이블 분할__
    - 테이블을 수직 또는 수평으로 분할하는 것
    - 수평분할(Horizontal Partitioning)
        - 레코드를 기준으로 테이블을 분할
        - 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 분할 
    - 수직분할(Vertical Partitioning)
        - 속성을 기준으로 테이블을 분할
        - 갱신위주의 속성분할
        - 자주 조회되는 속성 분할
        - 크기가 큰 속성 분할
        - 보안을 적용해야 하는 속벙 분할
    - 고려 사항
        - 기본키의 유일성 관리가 여려워짐
        - 수행 속도가 느려질 수 있다.
        - 데이커 검색에 중점을 두어 테이블 분할 여부를 결정


4. __중복 테이블 추가__
    - 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가
    - 추가하는 경우
        - 정규화로 인해 수행 속도가 느려지는 경우
        - 많은 범위의 데이터를 자주 처리해야 하는 경우
        - 특정 범위의 데이터만 자주 처리해야 하는 경우
        - 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우
    - 추가하는 방법
        - 집계 테이블의 추가 : 트리거의 오버헤드에 유의
        - 진행 테이블의 추가
        - 특정 부분만을 표함하는 테이블의 추가


5. __중복 속성 추가__
    - 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것
    - 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요

#### 시스템 카탈로그

1. __시스템 카탈로그의 의미__
    - 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스
    - 시스템 카탈로그 내의 각 테이블은 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블
    - 카탈로그들이 생성되면 데이터 사전(Data Dictionary)에 저장 -> 데이터 사전이라고도 한다.

2. __시스템 카탈로그 저장 정보__
    - 시스템 카탈로그에 저장된 정보를 메타 데이터(Meta-Data)라고 한다.
    - 메타 데이터의 유형
        - 데이터베이스 객체 정보 : 테이블(Table), 인덱스(Index), 뷰(View) 등의 구조 및 통계 정보
        - 사용자 정보 : 아이디, 패스워드, 접근 권한 등
        - 테이블의 무결성 제약 조건 정보 : 기본키, 외래키, Null 값 허용 여부 등
        - 함수, 프로시저, 트리거 등에 대한 정보

3. __카탈로그의 특징__
    - 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL을 이용하여 내용을 검색 가능
    - INSERT, DELETE, UPDATE문으로 카탈로그를 갱신하는 것은 허용되지 않는다.
    - 데이터베이스 시스템에 따라 상이한 구조를 갖는다.
    - DBMS가 스스로 생성하고 유지한다.
    - 카탈로그의 갱신
        - 사용자가 SQL문을 실행시켜 기본 테이블, 뷰, 인덱스 등에 변화를 주면 시스템이 자동으로 갱신
    - 분산 시스템에서의 카탈로그
        - 필요한 모드 ㄴ제어 정보를 가져야 한다.


4. __DBMS 내의 모듈 시스템__
    - 데이터 정의어 번역기(DDL Compiler)
        - DDL을 메타 데이터를 갖는 테이블로 변환하여 데이터 사전에 저장 
    - 데이터 조작어 번역기(DML Compiler)
        - DML을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신 
    - Data Directory
        - 데이터 사전에 수록된 데이터를 실제로 접근하는 데 필요한 정보를 관리 유지하는 시스템
        - 데이터 디렉터리는 시스템만 접근 가능
    - 질의 최적하기 : 사용자의 요구를 효율적인 형태로 변환하고 질의를 처리하는 좋은 전략 모색
    - 트랜잭션 처리기 : 복수 사용자 환경에서 평행으로 동시에 일어나는 트랜잭션 문제를 해결하여, 각가의 사용자가 데이터베이스 자원을 배타적으로 이용할 수 있도록 한다.



























