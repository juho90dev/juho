---
layout: post
title: 정처기[2]_소프트웨어 개발[5]
---

## 정처기_소프트웨어 개발 요약[5]
### 인터페이스 구현

#### 모듈 간 공통 기능 및 데이터 인터페이스 확인

1. __모듈 간 공통 기능 및 데이터 인터페이스의 개요__
    - 공통 기능 : 모듈의 기능 중에서 공통적으로 제공되는 기능
    - 데이터 인터페이스 : 모듈 간 교환되는 데이터가 저장될 파라미터

2. __모듈 간 공통 기능 및 데이터 인터페이스 확인 순서__
    1. 인터페이스 설계서를 통해 모듈별 기능을 확인
    2. 외부 및 내부 모듈을 기반으로 공통적으로 제공되는 기능과 각 데이터의 인터페이스를 확인

#### 모듈 연계
1. _ 모듈연계의 개요__
    - 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것
    - 대표적인 모듈 연계 방법 : EAI, ESB
2. __EAI(Enterprise Application Integration)__
    - 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
    - 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성(Determinacy)을 높여 준다
    - 구축 유형
        - Point-to-Point : 애플리케이션을 1:1로 연결하며 변경 및 재사용이 어렵다
        - Hub & Spoke
            - 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식
            - 확장 및 유지보수가 용이하며 허브 장애 발생 시 시스템 전체에 영향을 미친다.
        - Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식으로 확장성이 뛰어나며 대용량 처리가 가능하다
        - Hybrid 
            -  Hub & Spoke(그룹 내) 와 Message Bus(그룹 간)의 혼합방식
            -  데이터 병목 현상을 최소화 할 수 있다.


3. __ESB(Enterprise Service Bus)__
    - 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
    - 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향
    - 범용적으로 사용하기 위하여 애플리케이션과의 결합도(Coupling)를 약하게(Loosely) 유지
    - 관리 및 보안 유지가 쉽고, 높은 수준의 품질 지원이 가능


#### 인터페이스 구현

1. __인터페이스 구현__
    - 송/수신 시스템 간의 데이터 교환 및 처리를 실현해 주는 작업을 의미
    - 정의된 인터페이스 기능 구현을 기반으로 인터페이스 구현 방법 분석
    - 분석된 인터페이스 구현 정의를 기반으로 인터페이스 구현
    - 대표적으로 데이터 통신을 이용한 방법과 엔티티를 이용한 방법이 있다.

2. __데이터 통신을 이용한 인터페이스 구현__
    1. JSON(JavaScript Object Notation)
        - 속성-값 쌍(Attribute-Value Pairs)으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷
        - 비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용
    2. XML(eXtensible Markup Language)
        - 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
        - HTML의 문법이 각 웹 브라우저에서 상호 호환적이지 못하다는 문제와 SGML의 복잡함을 해결하기 위하여 개발
    3. AJAX(Asynchronous JavaScript and XML)
        - 자바 스크립트 등을 이용하여 클라이언트와 서버 간에 XML 데이터를 교환 및 제어함으로써 이용자가 웹 페이지와 자유롭게 상호 작용할 수 있도록 하는 비동기 통신 기술

3. __인터페이스 엔티티를 이용한 인터페이스 구현__
    - 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티로 상호 연계하는 방식
    - 일반적으로 인터페이스 테이블을 엔티티로 활용
    - 송/수신 인터페이스 테이블 구조는 상황에 따라 서로 다르게 설계할 수 도 있음

#### 인터페이스 

1. __인터페이스 보안 기능 적용__
    - 네트워크
        - 인터페이스 송/수신간 스니핑 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정
        - 인터페이스 아키텍처에 따라  IPSec, SSL, S-HTTP 등의 다양한 방식으로 적용
    - 애플리케이션
        - 소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 보안기능을 적용함
    - 데이터 베이스
        - 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용
    ----------------------------------------
    - 스니핑(Sniffing)
        - 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형

    - IPsec(IP Security
        - 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜로, 암호화 수행시 양방향 암호화를 지원함

    - 소프트웨어 개발 보안(시큐어 코딩, Secure Coding)
        - 소프트웨어 개발 과정에서 지켜야 할 일련의 보안 활동
        - ex) 입력 데이터 검증 표현, 보안 기능, 시간 및 상태, 에러 처리, 코드 오류, 캡슐화, API 오용

2. __데이터 무결성 검사 도구__
    - 시스템 파일의 변경 유무를 확인하고, 파일이 변경되었을 경우 이를 관리자에게 알려주는 도구
    - 인터페이스 보안 취약점을 분석하는데 사용
    - 해시(Hash) 함수를 이용하여 현재 파일 및 디렉토리의 상태를 DB에 저장한 후 감시하며, 현재상태와 DB상태가 달라지면 변경사실을 알려준다.
    - 대표적으로 Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck 등이 있다.


#### 인터페이스 구현 검증

1. __개요__
    - 인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것
    - 인터페이스 구현 검증 도구와 감시 도구를 이용하여 인터페이스의 동작 상태 확인 

1. __인터페이스 구현 검증 도구__
    - xUnit
        - 자동화된 해법을 제공하는 단위 테스트 프레임워크
        - JUnit(Java), CppUnit(C++), NUnit(.NET), HttpUnit(Http) 등 다양한 언어에 적용
    - STAF
        - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임 워크 
        - 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
    - FitNess 
        - 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크 
    - NTAF
        - FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크
    - Selenium
        - 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크
    - Satir
        - Ruby를 사용하는 애플리케이션 테스트 프레임워크

2. __인터페이스 구현 감시 도구__
    - APM을 사용하여 감시 가능
    - 대표적으로 스카우터(Scouter), 제니퍼(Jennifer) 등이 있다.


#### 인터페이스 오류 확인 및 처리 보고서 작성


1. __인터페이스 오류 발생 즉시 확인__
    - 오류 메시지 알람 표시
    - 오류 SMS 발송
    - 오류 내역 이메일 발송

2. __인터페이스 오류 발생 주기적인 확인__
    - 인터페이스 오류 로그 확인
        - 오류를 별도의 로그파일로 생성해 보관함, 자세한 오류 원인 및 내역을 확인할 수 있음 
    - 인터페이스 오류 테이블 확인
        - 오류사항의 확인이 쉬워 관리가 용이함, 오류사항이 구체적이지 않아 별도의 분석이 필요
    - 인터페이스 감시(APM) 도구 사용
        - 스카우터나 제니퍼 등의 인터페이스 감시 도구를 사용해 주기적 확인 
    -------------------------------------------------------
    - APM(Application Performance Management/Monitoring)
        - 애플리케이션의 성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 기능을 제공하는 도구
        - 리소스 방식 : Nagios, Zabbix, Cacti 등
        - 엔드투엔드(End-to-End) : VisualVM, 제니퍼, 스카우터 등




#### 빅오 표기법 / 순환 복잡도

1. __빅오 표기법(Big-O Notation)__
    - 알고리즘의 실행시간이 최악일 때를 표기하는 방법(시간 복잡도 -> 빅오 표기법)
    - 신뢰성이 떨어지는 오메가 표기법이나 평가하기 까다로운 세타 표기법에 비해 성능을 예측하기 용이하여 주로 사용
    - 복잡도
        - O(1)
            - 상수형 복잡도
            - 입력값에 관계없이 일정하게 문제 해결에 하나의 단계만을 거침
            - ex) 스택의 삽입(Push), 삭제(Pop)
            - 대표 알고리즘 : 해시함수(Hash Function) 
        - O(log2N)
            - 로그형 복잡도 
            - 문제 해결에 필요한 단계가 입력값 또는 조건에 의해 감소함
            - ex) 이진 트리(Binary Tree), 이진 검색(Binary Search)
            - 대표 알고리즘 : 이진 탐색(Binary Search)
        - O(n)
            - 선형 복잡도
            - 문제 해결에 필요한 단계가 입력값과 1:1의 관계를 가짐(수행 시간이 자료 크기와 직접적 관계 - 정비례)
            - ex) for문
            - 순차 탐색(Sequential Search)
        - O(N log2N)
            - 선형 로그형 복잡도
            - 문제 해결에 필요한 단계가 N(log2N)번만큼 수행됨
            - ex) 힙 정렬(Heap sort), 2-way 합병 정렬(Merge sort)
            - 합병 정렬
        - O(n2) 
            - 문제 해결에 필요한 단계가 입력값의 제곱만큼 수행
            - ex) 사
            - 삽입 정렬(Insertion Sort), 쉘 정렬(Shell Sort), 선택 정렬(Selection Sort), 버블 정렬(Bubble Sort), 퀵 정렬(Quick Sort)
        - O(2n)
            - 문제 해결에 필요한 단계가 2의 입력값 제곱만큼 수행됨
            - ex) 피보나치 수열(Fibonacci Sequence)


2. __순환 복잡도(Cyclomatic Complexity)__
    - 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도
    - 맥케이브 순환도(McCabe’s Cyclomatic) 또는 맥케이브 복잡도 메트릭(McCabe’s Complexity Metrics)라고도 한다.
    - 제어 흐름도 이론에 기초를 둔다.
    - 순환 복잡도를 이용하여 계산된 값은 프로그램의 독립적인 경로의 수를 정의
    - 모든 경로가 한 번 이상 수행되었음을 보장하기 위해 행해지는 테스트 횟수의 상한선을 제공
    - 제어 흐름도 G에서 순환 복잡도 V(G)는 다음과 같은 방법으로 계산
        -  순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산
        -  V(G) = E - N + 2 : E는 화살표 수, N은 노드의 수







