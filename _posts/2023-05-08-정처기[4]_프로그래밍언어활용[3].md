---
layout: post
title: 정처기[4]_프로그래밍 언어 활용[3]
---

## 정처기_프로그래밍 언어 활용[3]

### 응요 SQ 기초 기술 활용

#### 운영체제의 개념

1. __운영체제제(OS; Operating System)의 정의__
    - 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
    - 운영체제의 목적
        - 처리 능력(Throughput) : 일정 시간 내에 시스템이 처리하는 일의 양
        - 반환 시간(Turn Around Time) : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간
        - 사용 가능도(Availability) : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
        - 신뢰도(Reliability) : 시스템이 주어진 문제를 정확하게 해결하는 정도

2. __구성__ 
    - 제어 프로그램
        - 컴퓨터 전체의 작동 상태 감시, 작업의 순서 지정, 작업에 사용되는 데이터 관리 등의 역할을 수행하는 것
        - 감시 프로그램(Supervisor Program) : 자원의 할당 및 시스템 전체의 작동 상태를 감시하는 프로그램
        - 작업 관리 프로그램(Job Management Program) : 작업의 순서와 방법을 관리하는 프로그램
        - 데이터 관리 프로그램(Data Management Program) : 처리 및 전송을 관리하는 프로그램
    - 처리 프로그램
        - 제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램
        - 언어 번역 프로그램 : 고급언어로 작성한 원시 프로그램을 기계어 형태의 목적 프로그램으로 변환시키는 것(컴파일러, 어셈블러..)
        - 서비스 프로그램 : 사용자가 컴퓨터를 더욱 효율적으로 사용할 수 있도록 제작된 프로그램(분류/병합(Sort/Merge), 유틸리티 프로그램..)


3. __기능__
    - 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입·출력장치, 파일 및 정보 등의 자원을 관리
    - 자원의 스케줄링 기능을 제공
    - 사용자와 시스템 간의 편리한 인터페이스를 제공
    - 시스템의 각종 하드웨어와 네트워크를 관리·제어
    - 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
    - 시스템의 오류를 검사하고 복구
    - 입·출력에 대한 보조 기능을 제공



#### Windows

1. __개요__
    - 1990년대 마이크로소프트(Microsoft) 사가 개발한 운영체제

2. __주요 특징__
    - 그래픽 사용자 인터페이스(GUI; Graphic User Interface) : 마우스로 모든 작업을 수행하는 방식
    - 선점형 멀티태스킹(Preemptive Multi-Tasking) : 멀티태스킹을 하면서 운영체제가 CPU이용시간을 제어
    - PnP(Plug and Play, 자동 감지 기능) : 해당 하드웨어를 사용하는데 필요한 시스템 환경을 운영체제가 자동으로 구성
    - OLE(Object Linking and Embedding) : 다른 프로그램에서 작성된 개체를 현자 문서에 자유롭게 연결 및 삽입하여 편집 기능
    - 255자의 긴 파일명 : 파일 이름을 지정할 때 최대 255자
    - Single-User 시스템 : 컴퓨터 한 대를 한 사람만이 독점 사용



#### UNIX / LUNUX / MacOS

1. __UNIX의 개요 및 특징__
    - 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제
    - 시분할 시스템을 위해 설계된 대화식 운영체제(Open Sysytem)
    - 대부분 C언어로 작성, 이식성이 높으며 프로세스간의 호환성이 높다.
    - 크기가 작고 이해하기 쉬움
    - 다중 사용자, 다중 작업을 지원
    - 통신망 관리용 운영체제로 적합
    - 트리구조의 파일 시스템
    - 전문적인 프로그램 개발에 용이

2. __UNIX 시스템의 구성__
    - 사용자 -> 유틸리티 -> 쉘 -> 커널 -> 하드웨어
    - 커널(Kernel)
        - UNIX의 가장 핵심적인 부분
        - 컴퓨터가 부팅될 때 주기억장치에 적재된 후 상주하면서 실행
        - 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할을 담당
    - 쉘(Shell)
        - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기 
        - 시스템과 사용자 간의 인터페이스를 담당
        - DOS의 COMMAND.COM과 같은 기능을 수행
        - 명령어가 포함된 파일 형태로 존재하며 보조 기억장치에서 교체 처리가 가능
        - 파이프라인 기능을 지원하고 입/출력 재지정을 통해 출력과 입력의 방향을 변경 가능
    - Utility Program
        - 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용
        - DOS에서의 외부 명령어에 해당
        - 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다.


3. __LINUX의 개요 및 특징__
    - 1991년 리누스 토발즈(Lunx Torvalds)가 UNIX를 기반으로 개발한 운영체제
    - 프로그램 소스 코드가 무료로 공개 -> 프로그래머가 원하는 기능을 추가할 수 있고, 다양한 플랫폼에 설치하여 사용 가능 
    - UNIX와 완벽하게 호환
    - 배부분의특징이 UNIX와 동일


3. __MacOS의 특징__
    - 19080년대 애플사가 UNIX를 기반으로 개발한 운영체제
    - 애플 사에서 생산하는 제품에서만 사용이 가능
    - 드라이버 설치 및 install과 uninstall의 과정이 단순


#### 기억장치 관리의 개요

1. __기억장치 계층 구조의 특징__
    - 계층 구조
        - 레지스터
        - 캐시 기억장치
        - 주 기억장치
        - 보조기억장치
    - 상위의 기억장치일수록 접근 속도와 접근 시간이 빠르지만, 기억용량이 적고 고가이다.
    - 주기억장치는 각기 자신의 주소를 갖는 워드 또는 바이트들로 구성(주소를 이용하여 엑세스 가능)
    - 보조기억장치에 있는 프로그램이나 데이터는 직접 액세스 불가
    - 보조기억장치에 있는 데이터는 주기억장치에 적재된 후 CPU에 의해 액세스될 수 있다.

2. __기억장치의 관리 전략의 개요__
    - 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사요하기 위한 것
    - 반입(Fetch) 전략 : 보조기억장치에 보관중인 프로그램이나 데이타거 언제 주기억장치로 적재될 것인지를 결정하는 전략
        - 요구(Demand Fetch) 반입 : 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재하는 방법
        - 예상(Anticipatory Fetch) 반입 : 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재하는 방법
    - 배치(Placement) 전략 : 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
        - 최초 적합(First Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치
        - 최적 적합(Best Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치
        - 최악 적합(Worst Fit) : 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치
    - 교체(Replacement) 전략 : 주기억장치의 모든 영역이 이미 사용중인 상태에서 어느 영역을 교체하여 사용할 것인지 결정하는 전략
        - FIFO, OPT, LRU, LFU, NUR, SCR 등이 있다.


#### 주기억장치 할당 기법

1. __주기억장치 할당의 개념__
    - 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용
    - 연속 할당 기법 
        - 프로그램을 주기억장치에 연속으로 할당하는기법
        - 단일 분할 할당 기법 : 오직 한명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
            - 경계 레지스터가 사용
            - 오버레이 기법  : 주기억장치보다 큰 사용자 프로그램을 사용하기 위한 기법
            - 스와핑 기법 : 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법
        - 다중 분할 할당 기법 
    - 분산 할당 기법
        - 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법
        - 페이징기법
        - 세그머테이션 기법    


2. __다중 분할 할당 기법__
    - 고정 분할 할당(Multiple contiguous Fixed parTition allocation, MFT) 기법 = 정적 할당(Static Allocation) 기법
        - 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러개의 고정된 크기로 분할하고 각 영역에 할당하여 수행하는 기법
        - 프로그램 전체가 주기억장치에 위치해야 한다.
        - 내부 단편화 및 외부 단편화가 발생하여 주기억장치의 낭비가 많다.
    - 가변 분할 할당(Multiple contiguous Variable parTition allocation, MVT) 기법
        - 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
        - 주기억장치를 효율적으로 사용 가능
        - 프로세스 크기에 대한 제약이 적으나 영역과 영역사이에 단편화가 발생될 수 있다.



#### 가상기억장치 구현 기법 / 페이지 교체 알고리즘

1. __가상기억장치의 개요__
    - 보조기억장치의 일부를 주기억장치처럼 사용하는 것(용량이 작은 주기억장치를 큰 용량을 가진것처럼 사용)
    - 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리
    - 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용
    - 주소 변환 작업이 필요
    - 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결
    - 페이징 기법
        - 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재시켜 실행하는 기법
        - 프로그램을 일정한 크기로 나눈 단위를 페이지(Page), 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)
        - 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요
    - 세그먼테이션 기법
        - 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
        - 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment), 각 세그먼트는 고유한 이름과 크기를 갖는다
        -  세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요
        -  내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.



2. __페이지 교체 알고리즘__
    - 페이지 부재(Page Fault)가 발생했을 때 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
    - OPT(OPTimal replacement, 최적교체)
        - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체
        - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘
    - FIFO(First In First Out)
        - 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체
        - 프로그래밍 및 설계가 간단함
    - LRU(Least Recently Used)
        - 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
    - LFU(Least Frequently Used)
        - 사용 빈도가 가장 적은 페이지를 교체 
    - NUR(Not Used Recently)
        - 최근에 사용하지 않은 페이지를 교체 
        - LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있음
        - 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용
    - SCR(Second Chance Replacement, 2차 기회 교체)
        - 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것으로, FIFO 기법의 단점을 보완하는 기법


#### 가상기억장치 기타 관리 사항

1. __페이지 크기__
    - 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데 페이지의 크기에 따라 시스템에 미치는 영향이 다르다
    - 페이지 크기가 작을 경우
        - 페이지 단편화가 감소
        - 효율적인 워킹 셋을 유지
        - 기억장치 효율이 높아짐
        - 맴 테이블의 크기가 커지고, 매핑 속도가 느려짐 
        - 입/출력 시간은 늘어남
    - 페이지 크기가 클 경우
        - 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다
        - 전체적인 입·출력의 효율성이 증가
        - 페이지 단편화가 증가
        - 불필요한 내용까지도 주기억장치에 적재될 수 있다.

2. __Locality__
    - 프로세스가 실행하는 동안 주기억장치를 참조할 때 일부페이지만 집중적으로 참조하는 성질이 있다는 이론
    - 시간 구역성(Temporal Locality)
        - 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상 
        - 시간 구역성이 이루어지는 기억 장소
            - Loop(반복, 순환), 스택(Stack), 부 프로그램(Sub Routine), Counting(1씩 증감), 집계(Totaling)에 사용되는 변수(기억장소)
    - 공간 구역성(Spatial Locality)
        - 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
        - 공간 구역성이 이루어지는 기억장소
            - 배열 순회(Array Traversal), 순차적 코드의 실행, 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 사용 

3. __워킹 셋(Working Set)__
    - 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
    - 데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용
    - 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정
    - 시간에 따라 참조하는 페이지들의 집합이 변화하기 때문에 워킹 셋은 시간에 따라 변경됨

4. __스래싱(Thrashing)__
    - 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
    - 자주 페이지 부재가 발생함으로써 나타나는 현상으로, 전체 시스템의 성능이 저하된다.
    - 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소된다.
    - 방지 방법
        - 다중 프로그래밍의 정도를 적정 수준으로 유지
        - 페이지 부재 빈도를 조절하여 사용
        - 워킹 셋 유지
        - 부족한 자원을 증설, 일부 프로세스를 중단 

#### 프로세스의 개요

1. __프로세스(Process)의 정의__
    - 일반적으로 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미
    - 여러 형태로 정의 
        - PCB를 가진 프로그램
        - 실기억장치에 저장된 프로그램
        - 프로세서가 할당되는 실체
        - 프로시저가 활동중인 것
        - 비동기적 행위를 일으키는 주체
        - 운영체제가 관리하는 실행 단위


2. __PCBB(Process Control Block, 프로세스 제어 블록)__
    - 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳(Task Control Block 또는 Job Control Block)
    - 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거
    - PCB에 저장되어 있는 정보
        - 프로세스의 현태 상태
        - 포인터
        - 프로세스 고유 식별자
        - 스케쥴링 및 프로세스의 우선순위
        - CPU 레지스터 정보
        - 주기억장치 관리 정보
        - 입/출력 상태 정보
        - 계정 정보 


3. __프로세스 상태 전이__
    - 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것
    - 프로세스의 상태는 제출, 접수, 준비, 실행, 대기 상태로 나눌 수 있으며, 이 중 주요 세 가지 상태는 준비, 실행, 대기 상태이다
        - 제출(Submit) : 작업을 처리하기 위해 작업을 시스템에 제출한 상태
        - 접수(Hold) : 제출된 작업이 디스크의 할당위치에 저장된 상태
        - 준비(Ready) : 프로세서를 할당받기 위해 기다리고 있는 상태
        - 실행(Run) : 프로세서를 할당받아 실행되는 상태
        - 대기(Wait),보류,블록(Block) : 입/출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 완료될 때까지 대기하고 있는 상태
        - 종료(Terminated, Exit) : 프로세스 할당이 해제된 상태


4. __프로세스 상태 전이 관련 용어__
    - Dispatch
        - 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정
    - Wake up
        - 입/출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정 
    - Spooling
        - 입/출력할 데이터를 직접 입/출력장치에 보내지 않고 나중에 한꺼번에 입/출력하기 위해 디스크에 저장하는 과정
    - 교통량 제어기(Traffic Controller)
        - 프로세스의 상태에 대한 조사와 ㅌ오보를 담당


5. __스레드(Thread)__
    - 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
    - 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상이면 다중 스레도라고 한다.
    - 경량 프로세스라고도 한다.
    - 독립적인 스케줄링의 최소 단위로서 프로스세의 역할을 담당
    - 스레드의 분류
        - 사용자 수준의 스레드
            - 사용자가 만든 라이브러리를 사용하여 스레드를 운용
            - 속도는 빠르지만 구현이 어려움 
        - 커널 수준의 스레드 
            - 운영체제의 커널에 의해 스레드를 운용
            - 속도는 느리지마 구현이 쉬움
    - 장점
        - 하나의 프로세스를 여러개의 스레드로 생성하여 병행성 증진
        - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상
        - 응답 시간을 단축
        - 실행 환경을 공유시켜 기억장소의 낭비가 줄어듦
        - 프로세스들 간의 통신이 향상
        - 공통적으로 접근 가능한 기억장치를 통해 효율적으로  
























