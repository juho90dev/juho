---
layout: post
title: 정처기[3]_데이터베이스구축[4]
---

## 정처기_데이터베이스 구축 요약[4]

### SQL 활용

#### 프로시저(Procedure)

1. __프로시저(Procedure)의 개념__
    - 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어
    - 호출을 통해 실행되어 미리 저장해 놓은 SQL 작업을 수행
    - 데이터베이스에 저장되어 수행 = 스토어드 프로시저
    - 시스템의 일일 마감 작업, 일괄 작업 등에 주로 사용
    - 구성도
        - DECLARE : 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의 / 선언부
        - BEGIN  : 시작 / 실행부
        - CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리
        - SQL : DML, DCL이 사입되어 데이터관리를 위한 작업 수행
        - EXCEPTION : 예외 발생 시 처리하는 방법 정의
        - TRANSACTION : 수행된 데이터 작업들을 DB에 저장할지 취소할지를 결정
        - END : 종료 (Begin / End 는 함께 다님)
    - 프로시저 생성
        - CREATE PROCEDURE 명령어 사용
        ```
        CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)[지역변수 선언]
        BEGIN
            프로시저 BODY;
        END;
        ```
        - OR REPLACE : 선택적인 예약어, 동일한 프로시저 이름이 이미 존재하는 경우 기존의 프로시저를 대체
        - 프로시저명 : 생성하려는 프로시저의 이름을 지정
        - 파라미터
        - 프로시저 BODY : 프로지서의 코드 기록
    - 프로시저 실행
        - EXECUTE 프로시저명; / EXEC 프로시저명; / CALL 프로시저명; 
    - 프로시저 제거
        - EROP PROCEDURE 프로시저명; 


#### 트리거

1. __트리거(Trigger)의 개요__
    - DB 시스템에서 Insert, Update, Delete 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL
    - 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용
    - DCL 사용 불가, DCL이 포함된 프로시저나 함수를 호출하는 경우 오류 발생
    - 오류가 있는 경우 데이터에도 영향을 끼친다.
    - 구성도
        - DECLARE : 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의 / 선언부
        - EVENT : 실행되는 조건 명시
        - BEGIN  : 시작 / 실행부
        - CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리
        - SQL : DML문이 사입되어 데이터관리를 위한 작업 수행
        - EXCEPTION : 예외 발생 시 처리하는 방법 정의
        - END : 종료 (Begin / End 는 함께 다님)
    - 트리거의 생성
        - CREATE TRIGGER 명령어 사용
        ```
        CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명
        REFFERENCEING [NEW | OLD AS 테이블명]
        [FOR EACH ROW [WHEN 조건식]]
        BEGIN
            트리거 BODY;
        END;
        ```
        - OR REPLACE : 동일한 트리거 이름이 이미 존재하는 경우, 기존의 트리거 대체
        - 동작시기 : 트리거가 실행될때 (AFTER or BEFORE)    
        - 동작 : 작업의 종류
        - NEW | OLD : 트리거가 적용될 테이블의 별칭 지정(NEW : 추가되거나 수정에 참여할 테이블, OLD : 수정되거나 삭제 전 대상이 되는 테이블)
        - FOR EACH ROW : 각 튜플마다 트리거 적용
        - WHEN 조건식 : 트리거를 적용할 튜플의 조건
        - 트리거 BODY : 트리거의 본문 코드(적어도 하나 이상의 SQL문이 있어야 한다)
    - 트리거 제거
        - DROP TRIGGER 트리거명; 

#### 사용자 정의 함수

1. __사용자 정의 함수의 개요__
    - 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며 종료 시 처리 결과를 단일값으로 반환하는 절차형 SQL
    - 데이터베이스에 저장되어 DML문의 호출에 의해 실행
    - 예약어 RETURN을 통해 결과값 반환
    - SELECT를 통한 조회만 가능
    - 프로시저 호출 불가
    - 구성도
        - DECLARE : 사용자 정의 함수 명칭, 변수 , 타입, 인수, 데이터 타입을 정의 / 선언부
        - BEGIN  : 시작 / 실행부
        - CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리
        - SQL : SELECT문이 사입되어 데이터관리를 위한 작업 수행
        - EXCEPTION : 예외 발생 시 처리하는 방법 정의
        - RETURN : 호출 프로그램에 반환할 값이나 변수 정의
        - END : 종료 (Begin / End 는 함께 다님) 
    - 함수 생성
        ```
        CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
        지역변수 선언
        BEGIN
            사용자 정의 함수 BODY;
            RETURN 반환값;
        END;
        ```
        - OR REPLACE : 동일한 이름이 존재할 경우 기존의 함수를 대체
        - 파라미터 : 
        - 사용자 정의 함수 BODY : 함수의 코드 기록, BEGIN과 END 사이에 적어도 하나의 SQL문이 있어야 한다.
        - RETURN 반환값 : 반환할 값이나 변수를 호출 프로그램으로 
    - 사용자 정의 함수 실행
        ```sql
        SELECT 사용자 정의 함수명 FROM 테이블명;
        INSERT INTO 테이블명(속성명) VALUES(사용자 정의 함수명);
        DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명;
        UPDATE 테이블명 SET 속성명 = 사용자 정의 함수명;
        ```
    - 사용자 정의 함수 제거
        - DROP FUNCTION 사용자 정의 함수명;

#### DBMS 접속 기술

1. __DBMS 접속의 개요__
    - 사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것 
    - 응용 시스템은 매개 변수를 전달받아 SQL을 실행하고 DBMS로부터 전달받은 결과를 사용자데게 전달하는 역할 수행
    - 웹 응용 시스템은 웹 서버와 웹 애플리케이션 서버로 구성
    - 웹 응용 시스템의 구조
        - 사용자 <-> 웹서버 <-> WAS <-> DBMS
        - 사용자는 웹 서버에 접속해 데이터를 주고 받고 웹 서버는 WAS에게 해당 요청을 전달한다.
        - WAS는 수신한 요청을 트랜잭션 언어로 변환한 후 DBMS에 전달해 데이터를 받으면 이 데이터를 웹서버로 응답하여 사용자에게 도달하게 한다.

2. __DBMS 접속 기술__
    - DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크 등을 의미
    - JDBC(Java DataBase Connectivity)
        - 1997년 2월 썬 마이크로시스템에서 출시 
        - Java언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API 
        - 접속하려는 DBMS에 대한 드라이버가 필요
    - ODBC(Open DataBase Connectivity)
        - 1992년 9월 마이크로소프트에서 출시
        - 데이터베이스에 접근하기 위한 표준 개방형 API로 개발 언어에 관계없이 사용 가능
        - 접속하려는 DBMS에 맞는 드라이버가 필요하지만, 해당 DBMS의 인터페이스를 알지 못하더라도 ODBC 문장을 사용하여 SQL을 작성하면 ODBC에 포함된 드라이버 관리자가 해당 DBMS의 인터페이스에 맞게 연결해준다.
    - MyBtis
        - JDBC 코드를 단순화하여 사용할 수 있는 SQL Mapping 기반 오픈 소스 접속 프레임워크
        - DB에 접속하기 위해 다양한 메소드를 호출,해제하는데 이를 간소화했고 접속 기능을 강화
        - SQL 문장을 분리하여 XML 파일을 만들고, Mapping을 통해 SQL 실행

3. __동적 SQL(Dynamic SQL)__
    - 개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처리하는 것으로, 조건에 따라 SQL 구문을 동적으로 변경하여 처리 가능
    - SQL문의 일부 또는 전부를 입력받아 실행 가능
    - NVL 함수 사용할 필요 x
    - 프리컴파일 할때 구문 분석, 접근 권한 확인 x
    - 정적SQL vs 동적SQL
        - 정적 SQL
            - SQL 구성 : 커서를 통한 정적 처리
            - 개발 패턴 : 커서의 범위 안에서 반복문을 활용하여 SQL작성
            - 실행 속도 : 빠름
            - 사전 검사 : 가능
        - 동적 SQL
            - SQL 구성 : 문자열 변수에 담아 동적 처리
            - 개발 패턴 : NVL 함수 없이 로직을 통해 SQL 작성
            - 실행 속도 : 느림
            - 사전 검사 : 불가능 

#### SQL 테스트

1. __SQL 테스트의 개요__
    - SQL이 작성 의도에 맞게 원하는 기능을 수행하는지 검증하는 과정
    - 단문 SQL 테스트
        - SQL과 TCL을 테스트하는 것으로 직접 실행하여 결과물 확인
    - 절차형 SQL 테스트
        - 디버깅을 통해 기능의 적합성 여부를 검증하고, 실행을 통해 결과 


#### ORM(Object-Relational Mapping)

1. __ORM(Object-Relational Mapping)의 개요__
    - 객체(Object)와 관계형 데이터베이스(Relational Database)의 데이터를 연결(Mapping)하는 기술
    - 객체지향 프로그래밍에서 사용할 수 있는 가상의 객체지향 데이터베이스를 만들어 프로그래밍 코드와 데이터를 연결
    - 가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적이므로 재사용 및 유지보수가 용이
    - 직관적이고 간단하게 데이터 조작 가능

2. __ORM 프레임워크__
    - ORM을 구현하기 위한 구조와 구현을 위해 필요한 여러 기능을 제공하는 소포트웨어
    - 종류
        - JAVA : JPA, Hibernate, EclipseLink, DataNucleus, Ebean 등
        - C++ : ODB, QxOrm 등
        - Python : Django, SQLAlchemy, Storm 등
        - iOS : DatabaseObject, Core Data 등
        - .NET : NHibernate, DatabaseObjects, Dapper 등
        - PHP : Doctrine, Propel, RedBean 등

3. __ORM의 한계__
    - 프레임워크가 자동으로 SQL을 작성하기 때문에 의도대로 작성되었는지 확인 해야 한다.
    - 객체지향적인 사용을 고려하고 설계된 데이터베이스가 아닌경우 프로젝트가 크고 복잡해질수록 적용하기 어렵다.
    - 기좁의 기업들은 ORM을 고려하지 않기때문에 변환하려면 시간과 노력 필요

#### 쿼리 성능 최적화

1. __쿼리 성능 최적화의 개요__
    - 데이터의 입/출력 애플리케이션의 성능 향상을 위해 SQL 코드를 최적화하는 것
    - 쿼리 성능을 최적화하기 전에 성능 측정 도구인 APM을 사용하여 최적화 할 쿼리를 선정해야 한다
    - 최적화 할 쿼리에 대해 옵티마이저가 수립한 실행 계획을 검토하고 SQL 코드와 인덱스를 재구성

2. __RBO vs CBO__
    - RBO(Rule Based Optimizer)
        - 최적화 기준 : 규칙에 정의된 우선순위
        - 성능 기준 : 개발자의 SQL 숙련도
        - 특징 : 실행 계획 예측이 쉬움
        - 고려사항 : 개발자의 규칙 이해도, 규칙의 효율성
    - CBO(Cost Based Optimizer)
        - 액세스 비용
        - 옵티마이저의 예측 성능
        - 성능 통계치 정보 활용, 예측이 복잡함
        - 비용 산출 공식의 정확성

3. __실행 계획(Excution Plan)__
    - DBMS의 옵티마이저가 수립한 SQL 코드의 실행 절차와 방법을 의미
    - EXPLAIN 명령어를 통해 확인, 그래픽이나 텍스트로 표현된다.

4. __쿼리 성능 최적화__
    - sql문이 더 빠르고 효율적으로 작동하도록 SQL 코드와 인덱스를 재구성하는 것
    - SQL 코드 재구성
        - WHERE절을 추가하여 일부 레코드만 조회하게 함으로써 비용 절약
        - 서브 쿼리에 특정 데이터가 존재하는지 확인할 때는 IN보다 EXISTS를 활용
        - 실행 계획이 잘못되었다고 판단되는 경우 힌트(HINT)를 활용하여 경로 및 조인순서 변경
    - 인덱스 재구성
        - 실행 계획을 참고하여 인덱스를 추가하거나 기존 인덱스의 열 순서를 변경
        - 인덱스의 추가 및 변경은 해당 테이브을 참조하는 다른 SQL문에도 영향을 끼칠 수 있다.
        - 단일 인덱스로 쓰거나 수정 없이 읽기로만 사용되는 테이블의 경우 IOT(Index-Organized Table)로 구성하는것을 고려 
























