---
layout: post
title: Java [07] - 상속
---

상속

## 상속

- 다른 클래스가 가지고 있는 멤버(필드, 메소드)들을 새로 작성할 클래스에서 직접 만들지 않고 상속을 받음으로써 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능
- 목적 : 클래스의 재사용, 연관된 일련의 클래스들에 대한 공통적인 규약 정의
- 간결한 코드로 새로운 클래스 작성 가능.


1. **모든 클래스는 Object클래스의 후손**
    - Object클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
2. **부모클래스의 생성자, 초기화 블록은 상속 안 됨**
    - 자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행
    - 자식 클래스 생성자 안에 부모 클래스 생성자를 호출하고 싶으면 super() 활용
3. **부모의 private멤버는 상속은 되지만 직접 접근 불가**
    - 자식 객체 생성 시에 부모의 필드 값도 전달 받은 경우,
      자식 생성자 안에서 부모의 private 필드에 직접 접근하여 대입 불가
      super() 이용하여 전달받은 부모 필드 값을 부모 생성자 쪽으로 넘겨 생성하거나 setter, getter 메소드를 이용하여 접근

- 방법
    - 클래스 간의 상속 시에는 extends 키워드 사용

- 표현식
    ```java
    [접근제한자] class 클래스명(자식클래스) extends 클래스명(부모클래스 == super()라고도 함.) {}
    ex)
    public class Academy extends Company {}
    ```

- 단일 상속
    - 클래스간의 관계가 다중 상속보다 명확하고 신뢰성 있는 코드 작성
        - 자바에서는 다중 상속 미지원 → 단일상속만 지원
- 다중상속
    - 자바에서는 미지원


- super( )
    - 부모생성자를 호출 하는 메소드 , 기본적으로 후손 생성자에 부모 생성자 포함
    - 후손 객체 생성 시에는 부모부터 생성이 되기 때문에 후손클래스 생성자 안에는 부모 생성자를 호출하는 super()가 첫 줄에 존재 
    - 매개변수 있는 부모 생성자 호출은 `super(매개변수...)`를 넣으면 됨



- 오버라이딩
    1. 특징
        - 자식 클래스가 상속 받은 부모 메소드를 재작성 하는 것
        - 메소드 헤드라인 위에 반드시 Annotation, @Override 표시
        - 접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능
        - 부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정 가능
    2. 성립조건
        - 메소드 이름 동일 
        - 매개변수의 개수, 타입 동일 
        - 리턴 타입 동일
        - private 메소드 오버라이딩 불가
        - final 메소드 오버라이딩 불가

- 오버로딩
    - 한 클래스 내에서 같은 이름의 메소드를 여러 개 정의하는 것
    1. 성립 조건 
        - 같은 메소드 이름
        - 다른 매개변수 선언부(매개변수 타입, 개수, 순서)
    2. 주의 사항
        - 메소드의 리턴타입은 오버로딩 조건과 관계 없음

- final
    - 상속이 불가하다.
    ```java
    public final class FinalClass {}
    ```
    - final 메소드
    ```java
    상속 시 오버라이딩이 불가능한 메소드
    public final void method() {}
    ```

  





### 다형성

- 형태 = type = 자료형
- `여러 개의 형태를 갖는다`는 의미로
    - 하나의 행동으로 여러 가지 일을 수행하는 개념
- 하나의 타입으로 여러 타입을 사용할 수 있다.
- 부모 type은 자식 type의 객체를 저장할 수 있는 기능.

### 클래스의 `형변환`

- up Casting
    - 상속 관계에 있는 부모, 자식 클래스 간에 부모타입의 참조형 변수가 모든 자식 타입의 객체 주소를 받을 수 있음
- down Casting
    - 자식 객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야 할 경우, 부모 클래스 타입의 참조형 변수를 자식 클래스 타입으로 형 변환하는 것

### Instanceof 연산자
- 현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참조하고 있는지 확인 할 때 사용하는 연산자로 클래스 타입이 맞으면 true, 맞지 않으면 false 반환
    ```java
    if(레퍼런스 instanceof 클래스타입) {
    //true일때 처리할 내용, 해당 클래스 타입으로 down casting 
    }
    ```

  

### 추상클래스

- 추상클래스 (미완성 클래스)
    - 상속을 받아서 이용 
    - - 몸체가 없는 메소드를 포함한 클래스는 무조건 추상클래스로 만들어야한다.

- 추상메소드
    - 구현부가 없는 것 -> 선언부만 작성. 
    - 상속받는 클래스(부모클래스)에서 상속을 받았으면 반드시 오버라이딩으로 재정의 한다.(강제적으로)
    ```java
    [접근제한자] abstract 반환형 메소드명(자료형 변수명);
    ```

    

### 인터페이스

    ```java
    [접근제한자] interface 인터페이스명 {
            // 상수도 멤버로 포함할 수 있음			
            public static final 자료형 변수명 = 초기값;

            //추상메소드만 선언 가능
            [public abstract] 반환자료형 메소드명([자료형 매개변수])
            // public absract가 생략되기 때문에
            // 오버라이딩 시 반드시 public 표기해야함.
    }
    ```
1. 모든 인터페이스의 메소드는 public이고 abstract임.   -> 미완성, 자체생성 불가능
2. 변수는 묵시적으로 public static final
    - 인터페이스 변수의 값을 변경하면 컴파일에러 발생
3. 참조형 변수로는 가능
    - 다형성 가능.(상위 클래스 역할 - ex. 수업시간에 한 Character 클래스)


