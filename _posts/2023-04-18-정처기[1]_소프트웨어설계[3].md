---
layout: post
title: 정처기[1]_소프트웨어 설계[3]
---

## 정처기_소프트웨어 설계 요약[3]
### 애플리케이션 설계

#### 소프트웨어 아키텍처

1. __소프트웨어 아키첵쳐의 설계__
    - 기본적으로 좋은 품질을 유지하면서 사용자의 비기능적 요구사항으로 나타난 제약을 반영하고, 기능적 요구사할을 구현하는 방법을 찾는 해결 과정
2. __상위설계/하위설계__
    - 상위 설계
        - 별칭 : 아키텍쳐 설계, 예비 설계
        - 설계 대상 : 시스템의 전체적인 구조
        - 세부 목록 : 구조, DB, 인터페이스
    - 하위 설계
        - 모듈 설계, 상세 설계
        - 시스템의 내부 구조 및 행위
        - 컴포넌트, 자료 구조, 알고리즘


3. __소프트웨어 아키텍쳐 설계의 기본 원리__
    - 모듈화(Modularity) - 시스템의 기능들을 모듈단위로 나눔(시스템의 수정 및 재사용, 유지관리등을 용이하도록)
    - 추상화(Abstraction) - 문제의 전체적이고 포과적인 개념을 설계한 후 차례로 세분화하여 구체화시키는것
        - 과정 추상화, 데이터 추상화, 제어 추상화 
    - 단계적 분해(Stepwise Refinement) -  Niklaus Wirth에 의해 제안된 하향식 설계 전략 -> 상위부터 하위로 구체화
    - 정보 은닉(Information Hiding) - 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법

4. __소프트웨어 아키텍처의 품질 속성__
    - 소프트웨어 아키텍처가 요구 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 시스템, 비즈니스, 아키텍쳐 측면으로 구분하여 구체화 시켜 놓은것
    - 시스템 측면 : 성능, 보안, 가용성, 기능성, 사용성, 변경용이성, 확장성 등
    - 비즈니스 츠면 : 시장 적시성, 비용과 혜택, 예상 시스템 수명등
    - 아키텍처 측면 : 개념적 무결성, 저확성, 완결성, 구축 가능성 등

5. __소프트웨어 아키텍처의 설계 과정__
    - 설계 목표 설정 - 설계에 영향을 주는 요구사항을 분석하여 전체 시스템의 설계 목표를 설정
    - 시스템 타입 결정 - 시스템과 서브시스템의 타입을 결정하고 아키텍처 패턴을 선택
    - 아키텍처 패턴 적용 - 아키텍처 패턴을 참조하여 시스템의 표준 아키텍처를 설계
    - 서브시스템 구체화 - 서브시스템의 기능 및 서브시스템간의 상호작용을 위한 동작과 인터페이스를 정의
    - 검토 - 설개 목표에 부합하는지, 요구사항이 잘 반영됬는지, 기본원리를 만족하는지 등을 검토



6. __협약에 의한 설계__
    - 컴포넌트를 설계할 때 클래스에 대한 여러가정을 공유할 수 있도록 명세한 것
    - 선행 조건 (Precondition)
    - 결과 조건 (Postcondition)
    - 불변 조건 (Invariant)


#### 아키첵처 패턴

1. __개요__
    - 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미
    - 서브 시스템들과 그 역할이 정의되어 있으며, 서브시스템 사이의 관계와 여러 규칙/지침 등이 포함되어 있다.


2. __패턴__
    - 레이어 패턴(Layer Pattern)
        - 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나
        - OSI 참조 모델
    - 클라이언트-서버 패턴(Client-Server Pattern)
        - 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
        - 클라이ㅓㄴ트와 서버는 요청와 응답을 받기 위해 동기화되는 경우를 제외하고 독립적 
    - 파이프-필터 패턴 (Pipe-Filter Patter)
        - 데이터 스트림 절차의 각 단계를 필터(Filter) 컴포넌트로 캡슐화하여 파이트(Pipe)를 통해 데이터를 전송하는 패턴
        - 필터 컴포넌트는 재사용성이 좋고, 추가가 쉬워 확장이 용이
        - 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능
        - 파이프-필터 패터은 데이터 변환, 버퍼링, 동기화 등에 주로사용
        - 대표적으로 UNIX의 쉘(Shell)

    - 모델-뷰-컨트롤러 패턴 (Model-View-Controller Pattern)
        - 서브 시스템을 3개의 부분으로 구조화 하는 패턴
        - 모델 (Model) : 시스템의 기능과 데이터를 보관
        - 뷰 (View) : 사용자에게 정보 표시
        - 컨트롤러 (Controller) : 사용자로부터 입력된 요청을 처리하기 위해 모델에게 명령을 보내고 모델로부터 받은 응답을 뷰에게 다시 보내는 역할

    - 기타패턴
        - 마스터-슬레이브 패턴 (Master-Slave Pattern) : 장애 허용 시스템과 병렬 컴퓨터 시스템에서 주로 활용
        - 브로커 패턴 (Broker Pattern) : 분산 환경 시스템에서 주로 활용
        - 피어-투-피어 패턴 (Peer-To-Peer Patter) : 피어를 하나의 컴포넌트로 간주, 각 피어는 클라이언스 혹은 서버가 될 수 있는 패턴
        - 이벤트-버스 패턴 (Event-Bus Pattern) : 
        - 블랙보드 패턴 (Blackboard Pattern) : 음성 인식, 차량 식별, 신호 해석등에 주로 활용
        - 인터프리터 패턴 (Interpreter Patter) : 코드의 각 라인을 수행하는 방법을 지정


#### 객체지향(Object-Oriented)

1. __개요__
    - 소프트웨어를 개발할 때 객체들을 조립해서 작성할 수 있는 기법
    - 소프트웨어의 재사용 및 확장이 용이하여 빠르게 개발이 가능하고 유지보수가 쉽다
    - 복잡한 구조를 단계적/계층적으로 표현, 병렬처리 지원

2. __객체__
    - 데이터와 데이터를 처리하는 함수를 묶어놓은 하나틔 소프트웨어 모듈
    - 데이터 : 객체가 가지고 있는 정보(속성, 상태, 분류 등등..)
    - 함수 : 객체가 수행하는 기능(객체가 갖는 데이터를 처리하는 알고리즘 -> 메소드, 서비스, 동작, 연산이라고도 함)
    - 특성
        - 독립적으로 식별 가능한 이름을 가지고 있다.
        - 객체가 가질 수 있는 조건 -> 상태 (일반적으로 시간에 따라 변함)
        - 객체와 객체는 상호 연관성에 의한 관계가 형성
        - 객체가 반응할 수 있는 메시지의 집합을 행위라고 하며, 객체는 행위의 특징을 나타낼 수 있다.
        - 일정한 기억장소를 가지고 있다
    - 객체의 메소드는 다른 객체로부터 요청을 받았을때 정해진 기능을 수행

3. __클래스(Class)__
    - 공통된 속성과 연산을 갖는 객체의 집합
    - 데이터를 추상화하는 단위
    - 클래스에 속한 각각의 객체를 인스턴스라고 한다.


4. __캡슐화 (Encapsulation)__
    - 데이터화 데이터를 처리하는 함수를 하나로 묶는 것
    - 인터페이스를 제외한 세부내용이 은폐되어 외부에서의 접근이 제한적이기때문에 외부모듈의 변경으로 인한 파급효과가 적다.
    - 재사용이 용이
    - 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.


5. __상속 (Inheritance)__
    - 이미 정의된 상위클래스의 모든 속성과 연산을 하위클래스가 물려 받는것
    - 하위클래스는 상위클래스의 모든 속성과 연산을 자신의 클래스 내에서 정의하지 않고 자신의 속성으로 사용할 수 있다.
    - 하위 클래스는 상속받은 속성과 연산외 새롭게 추가하겨 사용할 수 있다.

6. __다형성 (Polymorphism)__
    - 객체가 연산을 수행하게 될때 하나의 요청에 대해 각각체 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미
    - 예)
        - '+' 연산자는 숫자연산기능과 문자를 연결해주는 기능
        - 오버로딩(Overloading) : 메소드는 같지만 매개변수의 타입과 개수를 다르게 하여 여러 기능을 정의할 수 있다.
        - 오버라이딩(Overring) : 사우이 클래스에서 정의한 메소드와 이름은 같지만 메소드 안의 실행코드를 다르게 하여 자식클래스에서 재정의할 수 있다.

7. __연관성 (Relationship)__
    - 두 개 이상의 객체들이 상호 참조하는 관계를 말한다.
    - 종류
        - is member of (Association) : 연관화 -> 2개 이상의 객체가 상호 관련되어 있음을 의미
        - is instance of (Classfication) : 분류화 -> 동일한 형의 특성을 갖는 객체들을 모아 구성
        - is part of (Aggregation) : 집단화 -> 관련있는 객체들을 묶어 하나의 상위 객체를 구성
        - is a 
            - 일반화 (Generalization) : 공톡적인 성질들로 추상화한 상위 객체를 구성
            - 특수화/상세화 (Specialization) : 상위 객체를 구체화하여 하위 객체를 구성

#### 객체지향 분석 및 설계

1. __객체지향 분석(OOA, Object Oriented Analysis)의 개념__
    - 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과 연산, 그들 간의 관계등을 정의하여 모델링 하는 작업


2. __객체지향 분석의 방법론__
    1. Rumbaugh(럼바우) 방법 : 가장 일반적으로 사용, 분석활동을 객체, 동적, 기능모델로 나누어 수행하는 방법
    2. Booch(부치) 방법 : 미시적, 거시적 개발 프로세서를 모두 사용, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의
    3. Jacobson : Use Case를 강조하여 사용하는 분석 방법
    4. Coad와 Yourdon : E-R 다이어그램을 사용하여 모델링하며 객체식별, 구조식별, 주제정의, 속성과 인스턴스정의 등의과정으로 구성 
    5. Wirfs-Brock : 분석과 설계간의 구분이 없고, 고객명세서를 평가해서 설계작업까지 연속적으로 수행하는 기법



3. __럼바우(Rumbaugh)의 분석 기법__
    - 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링 하는 기법
    - 객체 모델링기법(OMT, Obhect-Modeling Technique)이라고도 한다.
    - 객체 모델링 -> 동적 모델링 -> 기능 모델링 순으로 이루어진다.
    - 객체 모델링(정보 모델링) : 속멍과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시 <br>
    - 동적 모델링 : 상태 다이어그램을 이용하여 시간의 흐름에 따른 동적인 행위를 표현 <br>
    - 기능 모델링 : 자ㅏ료 흐름도를 이용하여 처리 과정을 표현한 모델링




4. __객체지향 설계 원칙__
    - 5가지 원칙으로 , SOLID 원칙이라고도 불린다.
    1. 단일책임원칙(SRP, Single Responsibility Principle) : 객체는 단 하나의 책임만 가져야 한다
    2. 개방-폐쇄 원칙(OCP, Open-Closed Principle) : 기존의 코드를 변경하지않고 기능을 추가할 수 있도록 설계해야 한다.
    3. 리스코프 치환원칙(LSP, Liskov Substilution Principle) : 자식클래스는 최소한 부모클래스에서 정의된 기능은 수행 할 수 있어야한다.
    4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle) : 사용하지 않는 인터페이스와 의존관계를 맺거나 영향을 받지 않아야 한다.
    5. 의존 역전 원칙(DIP, Dependency Inversion Principle) : 추상성이 높은 클래스와 의존 관계를 맺어야 한다.


#### 모듈

1. __모듈(Module)의 개요__
    - 모듈화를 통해 분리된 시스템의 각 기능들
    - 단독으로 컴파일이 가능하며, 재사용 가능
    - 모듈의 기능적 독립성은모듈이 하나의 기능만을 수행하고 다른 모듈과의 과도한 상호작용을 배제하는 것
    - 독립성은 결합도/응집도에 의해 측정

2. __결합도/응집도__
    - 결합도(Coupling)
        - 모듈 간의 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미
        - 다양한 결합으로 모듈 구성 가능
        - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.
        - 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.
        - 종류(약함에서 강함순)
            - 자료 결합도 : 모듈 간의 인터페이스가 자료 요소로만 구성될 때
            - 스탬프 결합도 : 모듈 간의 인터페이스로 가료 구조가 전달될 때
            - 제어 결합도 : 제어 신호를 이용하여 통신하거나 제어 요소를 전달할 때
            - 외부 결합도 : 선언한 데이터를 외부의 다른 모듈에서 참조할 때
            - 공통(공유) 결합도 : 공통 데이터 영역을 여러 모듈이 사용할 때
            - 내용 결합도 : 다른 모듈의 내부 기능 및 그 내부 자료를 참조하거나 수정할 때
    - 응집도(Cohesion)
        - 모듈이 독립적인 기능으로 정의되어 있는 정도
        - 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다.
        - 종류(약함에서 강함순)
            - 우연적 응집도 : 서로 관련없는 요소로만 구성된 경우
            - 논리적 응집도 : 유사하거나 특정형태로 분류되는 처리 요소들로 모듈이 형성되는 경우
            - 시간적 응집도 : 특정 시간에 처리되는 기능을 모아 하나의 모듈로 작성할 경우
            - 절차적 응집도 : 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
            - 교환적 응집도 : 동일한 입/출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우
            - 순차적 응집도 : 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우
            - 기능적 응집도 : 모든 기능요소들이 단일 문제와 연관되어 수행될 경우

3. __팬인 (Fan-In) / 팬아웃 (Fan-Out)__
    - 팬인 : 어떤 모듈을 제어하는 모듈의 수
    - 팬아웃 : 어떤모듈에 의해 제어되는 모듈의 수

4. __N-S 차트 (Nassi-Schneiderman Chart)__
    - 논리의 기술에 중점을 둔 도형을 이용한 표현방법으로 박스 다이어그램, Chapin Chart이라고도 한다.
    - 제어 논리 구조를 표현(연속, 선택, 다중선택, 반복 등)
    - GOTO나 화살표 사용하지 않는다.
    - 조건이 복합되어 있는 곳의 처리를 시작적으로 명확히 식별하는데 적합
    - 선택과 반복구조를 시각적으로 표현
    - 이해하기 쉽고, 코드 변환이 용이
    - 작성이 어렵고, 임의로 제어를 전이하는 것이 불가능
    - 총체적인 구조표현과 인터페이스를 나타내기 어려움
    -  단일 입구/출구로 표현

#### 공통 모듈

1. __공통 모듈__
    - 여러 프로그램에서 공통적으로 사용할 수 있는 모듈
    - 계산식, 사용자 인증과 같은 기능들이 구성될 수 있다.
    - 설계과정에서 공통부분을 식별하고, 명세를 작성할 필요가 있다.
    - 다음 명세기법을 준수해야 한다.
        - 정확성 (Correctness) : 해당 기능이 필요하다는 것을 정확히 작성
        - 명확성 (Clarity) : 해당 기능을 주으이적으로 해석되지 않도록 작성
        - 완전성 (Completeness) : 구현을 위해 필요한 모든 것을 기술
        - 일관성 (Consistency) : 공통 기능들가 충돌이 발생하지 않도록 작성
        - 추적성 (Traceability) : 요구사하으이 출처, 관련 시스템들의 관계를 파악할 수 있도록 작성

2. __재사용 (Reuse)__
    - 이미 개발된 기능들을 재구성하여 새로운 시스템 또는 기능개발에 사용하기 적합하도록 최적화시키는 작업
    - 누구나 이해할 수 있고 사용이 가능하도록 사용법 공개해야 한다.
    - 대상은 외부 모듈과의 결합도는 낮고, 응집도는 높아야 한다.

3. __모듈 설계 방안__
    - 결합도는 줄이고 응집도는 높여서 모듈의 독립성과 재사용성을 높인다.
    - 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지
    - 복잡도와 중복성을 줄이고 일관성을 유지
    - 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안된다.
    - 유지보수가 용이해야 한다.
    - 시스테므이 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.
    - 모듈간의 계층적 관계를 정의하는 자료가 제시되어야 한다.

#### 코드 (Code)
1. __개요__
    - 컴퓨터를 이용하여 자료를 처리하는 과정에서 분류,조합, 집계를 용이하게 하고 특정 자료의 추출을 쉽게하기 위해 사용하는 기호
    - 정보를 신속, 정확, 명료하게 전달할 수 있게 한다.
    - 주요 기능
        - 식별 기능 : 데이터 간의 성격에 따라 구분이 가능함
        - 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화할 수 있음
        - 배열 기능 : 의미를 부여하거나 나열할 수 있음
        - 표준화 기능 : 다양한 데이터를 기준에 맞추어 표현할 수 있음
        - 간소화 기능 : 복잡한 데이터를 간소화할 수 있음 

2. __종류__
    - 순차코드 (Sequence Code) : 최초의 자료부터 차례로 일련번호를 부여하는 방법
    - 블록코드 (Block Code) : 공통성이 잇는 것끼리 블록으로 구분하고 블록내에서 일련번호를 부여하는 방법
    - 10진 코드 (Decimal Code) : 0~9까지 10진 분할하고 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복
    - 그룹 분류 코드 (Group Classigication Code) : 일정 기준에 따라 대,중,소분류 등으로 구분하고 각 그룹안에서 일련번호를 부여하는 방법
    - 연상 코드(Mnemonic Code) : 대상 항목에 관계있는 문자, 기호를 이용하여 코드를 부여하는 방법 
    - 표의 숫자 코드 (Significant Digit Code) : 대상 항목의 성질 등 물리적 수치를 그대로 코드에 적용시키는 방법
    - 합성 코드 (Combined Code) : 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법



#### 디자인 패턴

1. __개요__
    - 각 모율의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할때 참조할 수 있는 해결방식
    - 문제 및 배경, 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
    - 개발 과정중에 문제가 생기면 문제에 해당하는 디자인패턴을 참고하여 적용하는 것이 더 효율적이다.
    - 디자인 패턴은 유형에따라 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개로 구성된다.

2. __장/단점__
    - 구조파악이 용이
    - 객체지형 설계및 구형의 생산성을 높인다.
    - 구조의 재사용을 통해 개발 시간과 비용이 절약된다.
    - 월활한 의사소통이 가능하다
    - 설계 변경 오청에 대한 유연한 대처가 가능하다.
    - 객체지향을 기반으로한 설계와 구현을 다루므라ㅗ 다른 기반의 개발을 적합하지 않다.
    -  초기 투자비용이 부담될 수 있다.

3. __생성 패턴__
    - 객체의 생성과 관련된 패턴
    - 총 5개의 패턴이 있다.
    - 객체의 생성과 참조 과정을 캡슐화하여 객체가 변경되거나 생성되도 영향을 받지 않도록 하여 프로그림에 유연성을 더해준다.
    - 종류
        - 추상 팩토리 (Abstract Factory) : 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
        - 빌더 (Builder) : 인스털스를 건축하듯이 조합하여 객체를 생성. 동일한 객체 생성이라도 다른 결과를 만들어 낼 수 있음
        - 팩토리 메소드 (Factory Method) : 객체 생성을 서브클래스에서 처리하도록 분리하여 캡슐화
        - 프로토 타입 (Prototype) : 원본 객체를 복제하는 방법으로 객체 생성, 비용이 큰 경우 주로 이용
        - 싱글톤 (Singleton) : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조가능, 단 동시에 참조 불가하다. 

4. __구조 패턴__
    - 클래스나 객체들을 조합하여 더 큰구조로 만들수 있게 해주는 패턴
    - 총 7개의 패턴이 있다.
    - 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
    - 종류
        - 어댑터 (Adapter) : 호환성이 없는 클래스들의 인터페이슬르 다른클래스가 이용할 수 있도록 변환해주는 패턴
        - 브리지 (Bridge) : 구현보와 추상층을 분리한 패턴 -> 기능과 구현을 두 개의 별도 클래스로 구현
        - 컴포지트 (Composite) : 복합객체와 단일객체를 구분없이 다룰때 사용
        - 데코레이터 (Decorator) : 객체간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 
        - 퍼싸드 (Facade) :복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성.(서브 클래스들의 기능을 간편하게 사용할 수 있게 한다.)
        - 플라이웨이트 (Flyweight) : 인스턴스가 필요할 때마다 생성하는 것이 아닌 공유해서 사용해서 메모리를 절약하는 패턴
        - 프록시 (Proxy) : 접근이 어려운 객체와 연결하려는 객체 사이에서 인터페이스 역할 하는 패턴(네트워크, 대용량 객체로의 접근에서 주로 사용)

5. __행위 패턴__
    - 클래스나 객체드링 서로 상호작용하는 방법이나 책임 붙배 방법을 정의하는 패턴
    - 총 11개의 패턴이 있다.
    - 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최호사 할 수 있도록 도와준다.
    - 종류
        - 책임 연쇄 (Chain of Responsibility) : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 처리하지 못하면 다음 객체가 처리하는 패턴
        - 커맨드 (Command) : 요청을 객체의 형태로 캡슐화하여 요청에 필요한 정보를 저장하거 로그에 남기는 패턴(각종 명령어들을 추상/구체클래스로 분리)
        - 인터프리터 (Interpreter) : 언어에 문법 표현을 정의하는 패턴 (SQL, 통신 프로토콜 등을 개발할때 사용)
        - 반복자 (Iterator) : 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴 (내부 노출없이 순차적 접근 가능)
        - 중재자 (Mediator) : 객체들간의 복잡한 상포작용을 캡슐화하여 객체로 정의하는 패턴 (의존성을 줄여 결합도를 감소)
        - 메멘토 (Memento) : 특정 시점에서의 객체 내부상태를 객체화하여 요청에 따라 해당 시점으로 돌릴 수 있는 기능 제공패턴(ctrl+z 같은 기능)
        - 옵서버 (Observer) : 객체의 상태가 변화하면 객체에 상속되어있는 다른 객체에게 상태 전달하는 패턴 (분산된 시스템 간에 이용)
        - 상태 (State) : 상태에 따라 동일한 동작을 다르게 처리해야할때 사용하는 패턴
        - 전략 (Strategy) : 동일한 계열의 알고리즘을 개별적으로 캡슐화하여 상호 교환할 수 있게 하는 패턴
        - 템플릿 메소드 (Template Method) : 공통된 내용을 상위클래스에서 정의하여 하위클래스에서 세부처리를 구체화하는 패턴
        - 방문자 (Visitor) : 가 ㄱ클래스들으 ㅣ데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴





