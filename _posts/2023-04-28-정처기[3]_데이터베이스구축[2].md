---
layout: post
title: 정처기[3]_데이터베이스구축[2]
---

## 정처기_데이터베이스 구축 요약[2]

### 물리 데이터베이스 설계

#### 물리 데이터베이스 설계

1. __물리 데이터베이스 설계__
    - 논리적 구조로 표현된 논리적 데이터베이스를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과저
    - 기본적인 데이터 단위는 저장 레코드(Stored Record)이다.
    - 물리적 설계 전에 기존 시스템을 분석하여 데이터 명명 규칙, 시스템 자원, 데이터베이스 관리 요소 등을 파악해야 한다.

2. __데이터 명명 규칙 파악__
    - 물리 데이터 모델의 설계 전에 파악해야 한다.
    - 데이터 표주환 및 논리 데이터베잇 설계의 결과물 등을 통해 파악
    - 물리 데이터베이스 설계와 논리 데이터베이스 설계에 적용되는 명명규칙은 서로 일관성을 유지해야 한다.
    - 논리적 데이터 요소를 물리적 데이터 요소로 전환할 때 동일 명칭 부여의 근거로 사용
    - 중보 구축 등을 방지
    - 도메인 : 객체에 포함된 속성들의 데이터 타입, 그기등을 표준화 규칙에 따라 일관성 잇게 정의한 것
    - 데이터 사전(데이터 용어사전) : 일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 데이터 속성의 논리명, 물리명, 용어 정의를 기술해 놓은 것
    - 프로젝트에서 사용하는 명칭 부여의 근거로 사용

3. __시스템 자원 파악__
    - 시스템 자원은 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소들로, 사전에 미리 파악
    - 하드웨어 자원
        - 중앙처리장치
        - 메모리
        - 디스트
        - I/O Controller
        - 네트워크  
    - 운영체제 및 DBMS 버전 : 데이터베이스 운영에 영향을 미칠 수 있으므로 적절하게 관리해야한다.
    - DBMS 파라미터 정보
        - 시스템별 DBMS 파라미터의 종류 및 관리 대상 등을 파악
        - DBMS의 저장공간, 메모리 드엥 대한 파라미터, 쿼리에서 활용하는 옵니마이저의 사용 방법 등을 파악

4. __데이터베이스 관리 요소 파악__
    - 데이터베이스 시스템의 환경에 따라 달라질 수 있으므로 미리 파악해야 한다.
    - 데이터베이스 관리 요소를 파악한 후 이를 기반으로 데이터베이스 시스템 조사 분석서를 작성
    - 시스템 조사 분석서를 기바능로 이것들의 범위와 특성을 파악
        - 데이터베이스 구조
        - 이중화 구성
        - 분산 데이터베이스
        - 접근 제어/접근 통제
        - DB암호화 

#### 테이블 저장 공간 설계

1. __테이블__
    - 데이터베이스의 가장 기본적인 객체로 로우(Row, 행)와 컬럼(Column, 열)으로 구성
    - 모든 데이터는 테이블에 저장
    - 논리 설계 단계의 개체(Entity)에 대응하는 객체
    - 종류에는 일반테이블, 클러스터 인덱스 테이블, 파티셔닝 테이블, 외부 테이블, 임시 테이블 등이 있다.

2. __일반 테이블__ 
    - 현재 사용되는 대부분의 DBMS에서 표준 테이블로 사용되는 테이블 형태
    - 저장되는 로우 위치는 속성 값에 상관없이 저장되는 순서에 따라 결정

3. __클러스터드 인덱스 테이블(Clustered Index Table)__
    - 기본키(Primary Key)나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
    - 일반적인 인덱스를 사용하는 테이블에 비해 접근 경로가 단축

4. __파티셔닝 테이블(Partitioning Table)__
    - 대용량의 테이블을 작은 논리적 단위인 파티션(Partition)으로 나눈 테이블
    - 파티션 키를 잘못 구성하면 성능 저하 등의 역효과를 초래
    - 레인피 파티셔닝(Range Partitioning) : 지정한 열의 값을 기준으로 분할(범위 분할)
    - 해시 파티셔닝(Hash Partitioning) : 해시 함수에 따라 데이터 분할(해시 분할)
    - 리스트 파티셔닝(List Partitioning) : 미리 정해진 그룹핑 기준에 따라 분할
    - 컴포지트 파티셔닝(Composite Partitioning) : 레인지 파티셔닝 이후 해시 함수를 적용(조합분할)

5. __외부 테이블(External Table)__
    - 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일
    - 데이터웨어하우스(Data Warehouse)에서 ETL(Extraction Transformation Loading)등의 작업에 유용하게 사욧ㅇ

6. __임시 테이블_(Temporary Table)_
    - 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
    - 저장된 데이터는 트랜잭션이 종료되면 삭제된다.
    - 절차적인 처리를 위해 임시로 사용하는 테이블

7. __컬럼(Column)__
    - 테이블의 열을 구성하는 요소, 데이터 타입, 길이 등으로 정의
    - 데이터 타입과 길이 지정시 고려사항
        - 가변 길이 데이터 타입 : 예상되는 최대 길이로 정의
        - 고정 길이 데이터 타입 : 최소 길이로 지정
        - 소수점 이하 자릿수 : 소수점 이하 자릿수는 반올림되어 저장
    - 데이터 타입에 따른 커럼의 물리적인 순서
        - 고정 길이 컬럼이고 NOT Null인 컬럼 : 앞쪽
        - 가변 길이 컬럼 : 뒤쪽
        - Null 값이 많을 것으로 예상되는 컬럼 : 뒤쪽 

8. __테이블스페이스(Tablespace)__
    - 테이블이 저장되는 논리적인 영역
    - 테이블을 저장하면 논리적으로는 테이블스페이스에 저장되고, 물리적으로는 해당 테이블스페이스와 연관된 데이터 파일(Data File)에 저장된다.
    - 테이블, 테이블스페이스, 데이터 파일에 나눠 관리하면 투명성이 보장된다.
    - 설계 시 고려사항
        - 업무별로 구분하여 지정
        - 대용량 테이블은 하나의 테이블스페이스에 독립적으로 저장
        - 테이블과 인덱스는 분리하여 저장
        - LOB(Large Object) 타입의 데이터는 독립적인 공간으로 지정


#### 트랜잭션 분석 / CRUD 분석

1. __트랜잭션(Transaction) 정의__
    - 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산
    - 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용
    - 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용

2. __트랜잭션의 상태__
    - 활동(Active) : 트랜잭션이 실행 중인 상태
    - 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태
    - 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
    - 부분 완료(Partially Committed) : 트랜잭션을 모두 성공적으로 실행한 후 Commit 연산이 실행되기 직전인 상태
    - 완료(Committed) : 트랜잭션을 모두 성공적으로 실행한 후 Commit 연산을 실행한 후의 상태

3. __트랜잭션의 특성__
    - 데이터의 무결성(Integrity)을 보장하기 위하여 DBMS의 트랜잭션이 가져야할 특성
    - Atomicity(원자성)
        - 트랜잭션의 연산은 Commit(완료)되거나 Rollback(복구)되어야 한다
        - 모든 명령은 완벽히 수행되어야 하며 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.
    - Consistency(일관성)
        - 길행을 성공적으로 완료하면 일관성 있는 데이터베이스 상태로 변환함
        - 시스템이 가지고 있는 고정 요소는 수행 전과 수행 완료 후의 상태가 같아야 한다.
    - Isolation(독립성, 격리성, 순차성)
        - 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
        - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음 
    - Durability(영속성, 지속성)
        - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

4. __CRUD 분석__
    - 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 앞글자만 모아서 만든 용어
    - CRUD분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것
    - 테이블에 발생되는 트랜잭션의 주기별 발생 횟수 파악, 테이블에 저장되는 데이터의 양을 유추 가능
    - 디스크 구성 시 유용한 자료로 활용
    - 연결 지연이나 타임아수 오류를 방지할 수 있다.

5. __CRUD 매트릭스__
    - 2차원 형태의 표, 행(Row)에는 프로세스를, 열(Column)에는 테이블을, 행과 열이 만나는 위치에는 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분석표
    - 프로세스의 트랜잭션이 테이블에 수행하는 작업을 검증
    - 각 셀에는 Create,Read,Update,Delete의 앞글자가 들어가며 C>D>U>r의 우선순위를 적용

6. __트랜잭션 분석__
    - CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션양을 분헉사여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB 용량을 산정하고 DB 구조를 최적화 하는 것
    - 업무 개발 담당자가 수행
    - 디스크 입/출력 분산을 통한 성능 향상을 가져올 수 있다.

7. __트랜잭션 분석서__
    - 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
    - 단위 프로세스 : 업무를 발생시키는 가장 작은 단위의 매트릭스
    - CRUD 연산
    - 테이블명, 컬럼명 : 프로세스가 접근하는 데이터베이스의 테이블명을 기록/컬럼명은 마침표로 연결하여 '테이블.컬럼명'으로 적는다.
    - 테이블 참조 횟수 : 프로세스가 테이블을 참조하는 횟수
    - 트랜잭션 수 : 주기별로 수행되는 트랜잭션 횟수
    - 발생 주기 : 연, 분기, 월, 일 시간 등 트랜잭션 횟수를 측정하기 위한 발생 주기


#### 인덱스

1. __인덱스(Index)의 개념__
    - 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
    - 데이터가 저장된 물리적 구조와 밀접할 관계가 있다.
    - 레코드가 저장된 물리적 구조에 접근하는 방법을 제공
    - 파일의 레코드에 대한 엑세스를 빠르게 수행
    - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적
    - 데이터 정의어(DDL)를 이용하여 사용자가 생성, 변경, 제거 가능
    - 인덱스가 없으면 모든 데이터 페이지를 확인하는 TABLE SCAN이 발생
    - 기본키를 위한 인덱스를 기본 인덱스라고 하며, 기본 인덱스가 아닌 인덱스를 보조 인덱스라 한다.
    - 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드(Clustered) 인덱스라 한다.
 
2. __인덱스의 종류__
    - 트리 기반 인덱스
        - 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
        - 상용 DBMS에서는 트리 구조 기반의 B+ 트리 인덱스를 주로 활용
        - B 트리 인데스
            - 일반적으로 사용되는 인덱스 방식
            - 루트 -> 하위노드로 키값의 크기를 비교해 나가면서 데이터를 검색
        - B+ 트리 인덱스
            - B 트리의 변형
            - 인덱스 세트와 순차 세트로 구분 
            - 인덱스 세트에 있는 노드들은 단말 노드에 있는 키 값을 찾아갈 수 잇는 경로로만 제공
            - 순차 세트에 잇는 단말 노드가 해당 데이터 레코드의 주소를 가리킨다.
            - 단말 노드만을 이용한 순차 처리가 가능
    - 비트맵 인덱스
        - 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
        - 키 값을 포함하는 로우(Row)의 주소를 제공하는 것
        - 분포도가 좋은 컬럼에 적합하고 효율적인 논리 연산이 가능
        - 튜플의 개수 계산에 적합하며 압축 효율이 좋다.
    - 함수 기반 인덱스
        - 컬럼의 값 대신 컬러멩 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용.
        - 데이터를 입력하거나 수정할 때 함수를 적용해야 하므로 부하가 발생할 수 있다.
        - 사용자 정의 함수일경우 시스템함수보다 부하가 더 크다
        - 적용 가능한 함수의 종류 : 산술식(Arithmetic Expression), 사용자 정의함수, PL/SQL Function, SQL Function, Pakage, C callout 등
    - 비트맵 조인 인덱스
        - 다수의 조인된 객체로 구성된 인덱스
        - 비트맨 인덱스와 물리적 구조가 동일
    - 도메인 인덱스
        - 개발자가 필요한 인덱스를 직접 만들어 사용하는 것, 확장형 인덱스(Extensible Index)라고도 한다.

3. __인덱스 설계__
    - 컬럼에 대해 기본적인 인덱스를 먼저 지정한 후 개발 단계에서 필요한 인덱스의 설계를 반복적으로 진행
    - 설계 순서
        - 인덱스의 대상 테이블이나 컬럼 등을 선정
        - 인덱스의 효율성을 검토하여 인덱스 최적화를 수행
        - 인덱스 정의서를 작성

4. __인덱스 대상 테이블 선정 기준__
    - MULTI BLOCK READ 수의 따라 판단
    - 랜던 액세스가 빈번한 테이블
    - 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블

5. __인덱스 대상 컬럼 선정 기준__
    - 인덱스 컬럼 분포도가 10~15% 이내인 컬럼
    - 가능한 한 수정이 빈번하지 않은 컬럼
    - OREDER BY, GROUP BY, UNION이 빈번한 컬럼
    - 분포도가 좁은 컬럼은 단독 인덱스로 설정
    - 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성

6. __인덱스 설계 시 고려사항__
    - 새로 추가되는 인덱스는 기존 엑세스 경로에 영향을 미칠 수 있다.
    - 인덱스를 지나치게 많이 만들면 오버헤드가 발생
    - 넓은 범위를 인덱스로 처리하면 많은 오버헤드가 발생
    - 인덱스를 만들면 추가적인 저장 공간이 필요하다.
    - 인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계



#### 뷰(View) 설계

1. __뷰(View)의 개요__
    - 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가진 가상 테이블
    - 물리적으로 존재하지 않지만 사용자에게는 있는 것처럼 간주
    - 임시적인 작업을 위한 용도로 활용
    - 조인문의 사용 최소화로 사용상의 편의성을 최대화

2. __뷰(View)의 특징__
    - 뷰는 기본텡블로부터 유도된 테이블이기 때문에 기본 테이블과 같은 형태의 구조를 사용하며, 조작도 기본 테이블과 거의 같다.
    - 가상테이블이기 때문에 물리적으로 구현되어 있지 않다.
    - 데이터의 논리적 독립성을 제공
    - 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
    - 뷰를 통해서만 데이터에 접근하게 되면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용
    - 뷰가 정의된 기본 테이블이나 뷰를 삭제하면, 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제
    - 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문을 사용

3. __뷰(View)의 장단점__
    - 장점
        - 논리적 데이터 독립성을 제공
        - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원
        - 사용자의 데이터 관리 용이
        - 접근 제어를 통한 자동보안 제공
    - 단점
        - 독립적인 인덱스를 가질 수 없음
        - 뷰의 정의를 ALTER로 변경 불가능 -> DROP후 CREATE로 다시 정의해야함
        - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름

4. __뷰 설계 순서__
    1. 대상 테이블 선정
    2. 대상 컬럼 선정
    3. 정의서 작성

5. __뷰 설계 시 고려 사항__
    - 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
    - 사용할 데이터를 다양한 관점에서 제시
    - 데이터의 보안 유지를 고려하여 설계


#### 클러스터 설계

1. __클러스터(Cluster)의 개요__
    - 데이터 저장 시 데이터 엑세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장방법
    - 클러스터링키로 지정된 컬럼 값의 순서대로 저장되고, 여러 개의 테이블이 하나의 클러스터에 저장

2. __특징__
    - 데이터 조회 속도는 향상시키지만 입력, 수정, 삭제에 대한 성능은 저하
    - 데이터의 분포도가 넓을수록 유리(분포도가 넓은 테이블을 클러스터링하면 저장공간 절약 가능)
    - 파티셔닝된 테이블에는 클러스터링을 할 수 없다.
    - 클러스터링된 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상

3. __대상 테이블__
    - 분포도가 넓은 테이블
    - 대량의 범위를 자주 조회하는 테이블
    - 입력, 수정, 삭제가 자주 발생하지 않는 테이블
    - 자주 조인되서 사용되는 테이블
    - ORDER BY, GROUP BY, UNION이 빈번한 테이블

#### 파티션(Patition)

1. __파티션(Patition)의 개요__
    - 대용량이 테이블이나 인덱스를 작은 논리적 단우인 파티션으로 나누는 것
    - 성능 저하를 방지하고 데이터 관리 용이하게 해준다.

2. __장/단점__
    - 장점
        - 데이터 접근 시 엑세스 범위를 줄여 쿼리 성능이 향상
        - 파티션별로 데이터가 분산, 디크스 성능 향상
        - 파티션별로 백업 및 복구가 되어 속도가 빠르다
        - 데이터 가용성 향상
        - 파티션 단위로 입/출력 분산
    - 단점
        - 세심한 관리가 요구
        - 테이블간 조인에 대한 비용이 증가
        - 용량이 작은 테이블에 파티션을 수행하면 성능 저하

3. __파티션의 종류__
    - 범위 분할(Range partitioning)
        - 지정한 열의 값을 기준을 범위를 지정하여 분할함 
    - 해시 분할(Hash partitioning)
        - 해시함수를 적용한 결과 값에 따라 분할
        - 데이터를 고르게 분산할 때 유용
        - 특정 데이터가 어디에 있는지 파악 불가
    - 조합 분할(Composite partitioning)
        - 범위 분할로 분할함 다음 해시 함수를 적용하여 다시 분할하는 방식
        - 파티션이 너무 커서 관리가 어려울때 용이 
    - 목록 분할(List partitioning)
        - 지정할 열 값에 대한 목록을 만들어 이를 기준으로 분할 
    - 라운드 로빈 분할(Round Robin Partitioning)
        - 레코드를 균일하게 분배하는 방식
        - 각 레코드가 순차적으로 분배되며, 기본키가 필요없음 


4. __인덱스 파티션__
    - 파틴션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것
    - 파티션된 테이블의 종속 여부에 따라 두가지로 나뉜다
        - Local Partitioned Index : 테이블 파티션고 인덱스 파티션이 1:1 대응되도록 파티셔닝한다.
        - Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝한다.
    - 인덱스 파티션키 컬럼의 위치에 따라 두가지로 나뉜다
        - Prefixed Partitioned Index : 인텍스 파티션키와 인덱스 첫 번째 컬럼이 같다
        - Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다르다


#### 데이터베이스 용량 설계

1. __데이터베이스 용량 설계__
    - 데이터가 저장될 공간을 정의하는 것
    - 테이블에 저장할 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야함

2. __데이터베이스 용량 설계목적__
    - 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.
    - 디스크의 입/출력 부하를 분산시키고 제널의 병목 현상을 최소화한다.
    - 오브젝트의 익스텐트 발생을 최소화 하여 성능 향상
    - 데이터 접근성을 향상시키는 설계 방법
        - 테이블의 테이블스페이스와 인덱스의 테이블스페이스를 분리하여 구성 
        - 테이블스페이스와 임시 테이블스페이스를 분리하여 구성
        - 테이블을 마스터 테이블과 트랜잭션 테이블로 분류
    
3. __데이터베이스 용량 분석 절차__
    - 데이터 예상 건수, 로우 길이, 보존 기간, 증가율 등 기초 자료를 수집하여 용량 분석
    - DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량 산정
    - 테이블과 인덱스의 테이블스페이스 용량 산정
    - 모든 데이터 용량과 시스템 용량을 합해 디스크 용량을 산정


#### 분산 데이터베이스 설계

1. __분산 데이터베이스 정의__
    - 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 컴퓨터 사이트에 분산되어 있는 데이터베이스

2. __분산 데이터베이스의 구성 요소__
    - 분산 처리기 : 자체적으로 처리 능력을 가지며, 지리적으로 분산되어 있는 컴퓨터 시스템
    - 분산 데이터베이스 : 지리적으로 분산되어 있는 데이터베이스로서 해당 지역의 특성에 맞게 데이터베이스가 구성
    - 통신 네트워크 : 분산 처리기들을 통신망으로 연결하여 논리적으로 하나의 시스템처럼 작동할 수 있도록 하는 통신 네트워크

3. __분산 데이터베이스의 목표__
    - 위치 투명성(Lacation Transparency)
        - 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음
    - 중복 투명성(Replication Transparency)
        - 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
    - 병행 투명성(Concurrency Transparency)
        - 다수의 트래잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다.
    - 장애 튜명성(Failure Transparency)
        - 트랜재션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리
    - 분할 투명성(Division Transparency)
        - 하나의 논리적 릴레이션이 여러 단편ㅇ로 분할되어 각 단편의 사본이 여려 시스템에 저장되어 있음을 인식할 필요가 없음  

4. __분할 데이터베이스의 장/단점__
    - 장점
        - 지역 자치성이 높음
        - 자료의 공유성 향상
        - 분산 제어 가능
        - 시스템 성능 향상
        - 중앙 컴퓨터의 장애가 전체 시스템에 영향을 끼치지 않음
        - 효용성과 융통성이 높음
        - 신뢰성 및 가용성이 높음
        - 점진적 시스템 용량 확장이 용이 
    - 단점
        - DBMS가 수행할 기능이 복잡
        - 데이터베이스 설계가 어려움
        - 소프트웨어 개발 비용이 증가
        - 처리 비용이 증가
        - 잠재적 오류가 증가 

5. __분산 데이터베이스 설계__
    - 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다.
    - 전역 관계망을 논리적 측면에서 소규모 단위로 분할한 후 , 분할된 결과를 복수의 노드에 할당하는 과정으로 진행
    - 분산 설계 방법
        - 테이블 위치 분산 : 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
        - 분할(Fragmentation)
            - 테이블의 데이터를 반할하여 분산시키는 것
            - 분할 규칙
                - 완전성(Completeness)
                - 재구성(Reconstruction)
                - 상호 중첩 배제(Dis-jointess)
        - 할당(Allocation)
            - 동일한 분할을 여러 개의 서버에 생성하는 방법
            - 비중복 할당방식 : 단일 노드에서만 분할지 존재하도록 하는 방식
            - 중복 할당방식 : 동일한 테이블을 다른 서버에 복제하는 방식, 부분 복제와 완전 복제가 있다.



#### 데이터베이스 이중화 / 서버 클러스터링

1. __데이터베이스 이중화(Database Replication)__
    - 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제해 관리하는 것
    - 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 사용자가 수행하는 작입어 동일하게 적용
    - 데이터베이스의 부하 감소

2. __데이터베이스 이중화의 분류__
    - 변경 내용의 전달 방식에 따라 Eager 기법과 Lazy 기법이 있다.
    - Eager 기법
        - 트랜잭션 수행 중 데이터 변경이 발생하면 이중화 된 모든 데이터베이스에 즉시 전달해 변경 내용이 즉시 적용되도록 하는 기법 
    - Lazy 기법
        - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성해 각 데이터베이스에 전달되는 기법
            - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주됨  

3. __데이터베이스 이중화 구성 방법
    - 활동-대기 방법(Active-Standby)
        - 한 DB가 활동 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활동 DB에 장애가 발생하면 대기 상태에 있던 DB가 자동으로 모든 서비스를 대신 수행 
    - 활동-활동 방법(Active-Active)
        - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공 

4. __클러스터링(Clustering)__
    - 두 대 이상의 서버를 하나의 서버로 운영하는 기술
    - 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성을 제공
    - 고가용성 클러스터링 : 하나의 서버에 장애 발생 -> 다른 서버가 대신 처리
    - 병렬 처리 클러스터링 : 하나의 작업을 여러 개의 서버에서 분산하여 처리



#### 데이터베이스 보안 / 암호화

1. __데이터 보안의 개요__
    - 데이터베이스의 일부분 또는 전체에 대해서 권한이 없는 사용자가 엑세스하는 것을 금지하기 위해 사용되는 기술
    - 데이터베이스 사용자들은 일반적으로 서로 다른 객체에 대하여 다른 접근 권리 또는 권한을 갖게 된다.

2. __암호화(Encrypton)__
    - 데이터를 보낼때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것
    - 암호화(Encrypton) 과정 : 암호화되지 않은 평문을 정보 보호를 위해 암호문으로 바꾸는 과정
    - 복호화(Decrypton) 과정 : 암호문을 원래의 평문으로 바꾸는 과정

3. __암호화 방식__
    - 개인키 암호 방식(Private Key Encryption) = 비밀키 암호 방식
        - 동일한 키로 데이터를 암호화하고 복호화한다.
        - 대칭 암호 방식 또는 단일키 암호화 기법이라고도 한다.
        - DB사용 권한이 있는 사용자만 나누어 가진다.
        - 종류
            - 전위 기법, 대체 기법, 대수 기법, 합쇼ㅓㅇ 기법  
    - 공개키 암호 방식
        - 서로 다른 키로 데이터를 암호화하고 복호화한다.
        - 암호화할 때 사용하는 키는 DB사용자에게 공개하고, 복호화할때의 키는 관리자가 관리
        - 비대칭 암호방식
        - 대표적으로 RSA(Rivest Shamir Adleman) 

4. __접근통제__
    - 데이터가 저장된 객체와 이를 사용하려는 주체사이의 정보 흐름을 제한하는 것
    - 접근통제 3요소
        - 접근통제 정책, 접근통제 매커니즘, 접근ㅌ오제 보안모델 
    - 접근통제 기술
        - 임의 접근통제(DAC; Discretionary Access Control)
            - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
            - 데이터 소유자가 접근통제 권한을 지정하고 제어 
        - 강제 접근통제(MAC; Mandatory Access Control)
            - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
            - 시스템이 접근통제 권한을 지정
            - 주체의 등급보다 높으면 읽기, 수정, 등록이 불가하고 같으면 읽기, 수정, 등록이 가능, 낮으면 읽기가 가능하다
            - 모델
                - 벨 라파듈라 모델 : 정보의 기밀성에 따라 상하 관계가 구분된 정보를 보호하기 위해 사용
                - 비바 무결성 모델 : 무결성을 보장, 비인가자에 의한 데이터 변형을 방지
                - 클락-윌슨 무결성 모델 : 직접 접근은 불하가지만 프로그램에 의해 접근이 가능한 보안 모델
                - 만리장성 모델 : 서로 이해 출동 관계에 있는 객체 간의 정보 접근을 통제하는 모델
        - 역할기반 접근통제(RBAC; Role Based Access Control)
            - 사용자의 역할에 따라 접근 권한을 부여하는 방식
            - 중앙관리자가 접근 통제 권한을 지정 

5. __접근통제 정책__
    - 어떤 주체가, 언제, 어디서, 어떤 객체에게, 어떤 행위에 대한 허용 여부를 정의하는 것
    - 신분 기반 정책 : 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법
        - IBP(Indivisual-Based Policy) : 단일 주체에 허가 부여
        - GBP(Group-=Based Policy) : 복수 주체에 허가 부여
    - 규칙 기반 정책 : 주체가 갖는 권한에 근거해 객체의 접근을 제한하는 방법
        - MLP(Multi-Level Policy) : 사용자 및 객체별로 지정된 기밀분류에 따른 정책
        - CBP(XCompartment-Based Polisy) : 집단별로 지정된 기밀 허가에 따른 정책
    - 역할 기반 정책 : 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법
        - 인사 담당자, DBA 등

6. __접근통제 매커니즘__
    - 정의된 접근통제 정책을 구현하는 기술적인 방법
    - 접근 통제 목록(Access Control List) : 객체를 기준으로 특정 객체에 대해 어떤 주체가 어떤 행위를 할 수 있는지를 기록한 모록
    - 능력 리스트(Capability) : 주체를 기준으로 주체에게 허가되 ㄴ자원 및 권한을 기록한 목록
    - 보안 등급(Security Level) : 주체나 객체 등에 부여된 보안 속성의 집합
    - 패스워드 : 주체가 자신임을 증명할 때 사용하는 인증 방법
    - 암호화 : 평문을 암호문으로 변환

























